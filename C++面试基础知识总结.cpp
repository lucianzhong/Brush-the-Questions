/*
1.  const
	<1>修饰变量，说明该变量不可以被改变；
	<2>修饰指针，分为指向常量的指针和指针常量；
	<3>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
	<4>修饰成员函数，说明该成员函数内不能修改成员变量。
*/	

//类
	class A{
	private:
		const int a;   // 常对象成员，只能在初始化列表赋值
	public:
		A();
		A(int x) :a(x) {};  // 初始化列表

		int getValue();         // 普通成员函数
		int getValue() const;   // 常成员函数，不得修改类中的任何数据成员的值
	};

	void function() {
		//对象
		A b;				// 普通对象，可以调用全部成员函数
		const A a;			// 常对象，只能调用常成员函数、更新常成员变量
		const A *p = &a;	// 常指针 
		const A &q = a;		// 常引用

		//指针
		char greeting[] = "Hello";				
		char *p1 = greeting;					// 指针变量，指向字符数组变量
		const char *p2 = greeting;				// 指针变量，指向字符数组常量
		char* const p3 = greeting;				// 常指针，指向字符数组变量
		const char * const p4 = greeting;		// 常指针，指向字符数组常量
	}


	void function1(const int var);		// 传递过来的参数在函数内不可变
	void function2(const char * var);	 // 参数指针所指内容为常量
	void function3(char * const var);	 // 参数指针为常指针
	void function4(const int &var);		// 引用参数在函数内为常量

	const int function5();			 // 返回一个常数
	const int * function6();		// 返回一个指向常量的指针变量，使用：const int *p = function6();
	int * const function7();		//// 返回一个指向变量的常指针，使用：int* const p = function7();




/*
2. static

	<1>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
	<2>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
	<3>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
	<4>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。	
*/
	static int n;
	static void fn();



	/*
	3. 
	this 指针
	this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。
	当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。
	当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
	this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
	this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。
	在以下场景中，经常需要显式引用 this 指针：
	为实现对象的链式引用；
	为避免对同一对象进行赋值操作；
	在实现一些数据结构时，如 list。
	
	*/



	/*
		4. 
		inline 内联函数
			<1>相当于把内联函数里面的内容写在调用内联函数处；
			<2>相当于不用执行进入函数的步骤，直接执行函数体；
			<3>相当于宏，却比宏多了类型检查，真正具有函数特性；
			<4>不能包含循环、递归、switch 等复杂操作；
			<5>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。	


			编译器对 inline 函数的处理步骤
			将 inline 函数体复制到 inline 函数调用点处；
			为所用 inline 函数中的局部变量分配内存空间；
			将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
			如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）


	*/

	inline int functionName(int a, int b);    //声明
	inline int functionName(int a, int b) {};  //定义

	class A {
		int doA() { return 0; } //隐式内联
	};

	class B {
		int doA();
	};
	inline int A::doA() { return 0; } //需要显式内联



	/*
		5. assert()
	断言，是宏，而非函数。assert 宏的原型定义在 <assert.h>（C）、<cassert>（C++）中，
	其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前
	
	*/

# define NDEBUG    // 加上这行，则 assert 不可用
#include <cassert>
	assert(p != NULL);


	/*
		6. sizeof()
		sizeof 对数组，得到整个数组所占空间大小。
		sizeof 对指针，得到指针本身所占空间大小。
	
	*/


	/*
	 7. pragma pack (n)
		设定结构体、联合以及类成员变量以 n 字节方式对齐	
	*/

#pragma pack(push)   // 保存对齐状态
#pragma pack(4)      // 设定为 4 字节对齐

	struct Test {
		char m1;
		double m4;
		int m3;
	};

#pragma pack(pop);	// 恢复对齐状态



	/*
	8.
	Bit mode : 2;
	类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。
		位域在内存中的布局是与机器有关的
		位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定
		取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域	
	*/



	/*
	9. 
		volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
		volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
		const 可以是 volatile （如只读的状态寄存器）
		指针可以是 volatile	
	*/
	volatile int i = 10;


	/*
	10. 
		extern "C"
		被 extern 限定的函数或变量是 extern 类型的
		被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和连接的
		extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。
	*/
#ifdef __cplusplus
	extern "C" {
#endif
		void *memset(void *, int, size_t);
#ifdef __cplusplus
	}
#endif


	/*
	11. 
		C++ 中 struct 和 class
			总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

			区别
			最本质的一个区别就是默认的访问控制
			默认的继承访问权限。struct 是 public 的，class 是 private 的。
			struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。
	*/


	/*
	12. 
		explicit 修饰的构造函数可用来防止隐式转换
	
	*/
	class Test1 {
	public:
		Test1(int n) {
			num = n;
		}
	private:
		int num;
	};

	class Test2 {
	public:
		explicit Test2(int n) {
			num = n;
		}
	private:
		int num;
	};

	Test1 t1 = 1;	// 隐式调用其构造函数，成功
	Test2 t2 = 1;	 // 编译错误，不能隐式调用其构造函数
	Test2 t3(1);	// 显式调用成功



	/*
	13. 
		enum 枚举类型
	限定作用域的枚举类型
	enum class open_modes { input, output, append };
	不限定作用域的枚举类型
	enum color { red, yellow, green };
	enum { floatPrec = 6, doublePrec = 10 };
	
	*/


	/*
		14. 
		decltype (expression)
		decltype 关键字用于检查实体的声明类型或表达式的类型及值分类	
	*/

	template <typename It>
	auto fcn(It begin, It end) -> decltype(*begin) {
		return *begin;
	}




	/*
		15. 
		成员初始化列表
		好处
		更高效：少了一次调用默认构造函数的过程。
		有些场合必须要用初始化列表：
		常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
		引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
		没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。
	
	*/

	/*
		16 面向对象三大特征 —— 封装、继承、多态
		封装
		把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
		关键字：public, protected, friendly, private。不写默认为 friendly。

		继承
		基类（父类）——> 派生类（子类）
		多态
		多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。
		C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。
		多态是以封装和继承为基础的。


		动态多态（晚绑定）
		虚函数：用 virtual 修饰成员函数，使其成为虚函数
		注意：

		普通函数（非类成员函数）不能是虚函数
		静态函数（static）不能是虚函数
		构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
		内联函数不能是表现多态性时的虚函数


		纯虚函数
		纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。
		virtual int A() = 0;


		虚函数、纯虚函数
		CSDN . C++ 中的虚函数、纯虚函数区别和联系

		类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
		虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。
		虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
		带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。
		虚函数指针、虚函数表
		虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
		虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。
		虚继承
		虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

		底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

		实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

		虚继承、虚函数
		相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
		不同之处：
		虚继承
		虚基类依旧存在继承类中，只占用存储空间
		虚基类表存储的是虚基类相对直接继承类的偏移
		虚函数
		虚函数不占用存储空间
		虚函数表存储的是虚函数地址
		模板类、成员模板、虚函数
		模板类中可以使用虚函数
		一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数
		抽象类、接口类、聚合类
		抽象类：含有纯虚函数的类
		接口类：仅含有纯虚函数的抽象类
		聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
		所有成员都是 public
		没有有定于任何构造函数
		没有类内初始化
		没有基类，也没有 virtual 函数
	
	*/

	class C {
	public:
		void function_1(int a);
		void function_1(int a, int b); //静态多态（早绑定） //函数重载
	};


	//动态多态使用
	class Shape {
	public:
		Shape();							 // 构造函数不能是虚函数
		virtual double calcArea() {};
		virtual  ~Shape();						// 虚析构函数,虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象
	};

	class Circle :public Shape {
	public:
		virtual double calcArea();
	};



	/*
		17.
	
	
	*/