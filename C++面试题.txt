 1.面向对象的程序设计思想是什么？
	答：把数据结构和对数据结构进行操作的方法封装形成一个个的对象

2.什么是类？
	把一些具有共性的对象归类后形成一个集合，也就是所谓的类
	
3.对象都具有的两方面特征是什么？分别是什么含义？
	答：对象都具有的特征是：静态特征和动态特征
		静态特征是指能描述对象的一些属性（成员变量），动态特征是指对象表现出来的行为（成员函数）
		
4.在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义？
	答：这样可以提高编译效率，因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大的提高了编译效率

5.在类的内部定义成员函数的函数体，这种函数会具备那种属性？
	答：这种函数会自动为内联函数，这种函数在函数调用的地方在编译阶段都会进行代码替换	
	
6.成员函数通过什么来区分不同对象的成员数据？为什么它能够区分？
	答：通过this指针指向对象的首地址来区分的

7. C++编译器自动为类产生的四个缺省函数是什么？
	答：默认构造函数，拷贝构造函数，析构函数，赋值函数
	
8.拷贝构造函数在哪几种情况下会被调用？
	答： 1.当类的一个对象去初始化该类的另一个对象时；
         2.如果函数的形参是类的对象，调用函数进行形参和实参结合时；
         3.如果函数的返回值是类对象，函数调用完成返回时
		 
9.构造函数与普通函数相比在形式上有什么不同？（构造函数的作用，它的声明形式来分析）
	答：构造函数是类的一种特殊成员函数，一般情况下，它是专门用来初始化对象成员变量的
		构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值。
		
10.什么时候必须重写拷贝构造函数？
	答：当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝
	
11.构造函数的调用顺序是什么？
	答：1.先调用基类构造函数
		2.按声明顺序初始化数据成员
		3.最后调用自己的构造函数。
		
12.哪几种情况必须用到初始化成员列表？
	答：类的成员是常量成员初始化；
		类的成员是对象成员初始化，而该对象没有无参构造函数。
		类的成员为引用时。		
		
13.什么是常对象？
	答：常对象是指在任何场合都不能对其成员的值进行修改的对象		
		
14.静态函数存在的意义？
	答：静态私有成员在类外不能被访问，可通过类的静态成员函数来访问；		
		当类的构造函数是私有的时，不像普通类那样实例化自己，只能通过静态成员函数来调用构造函数

15.在类外有什么办法可以访问类的非公有成员？
	答：友元，继承，公有成员函数。		
		
16.什么叫抽象类？
	答：不用来定义对象而只作为一种基本类型用作继承的类		
		
17.运算符重载的意义？
	答：为了对用户自定义数据类型的数据的操作与内定义的数据类型的数据的操作形式一致		
		
18.不允许重载的5个运算符是哪些？
	答：1. .*（成员指针访问运算符号）
		2. ：：域运算符
		3. Sizeof 长度运算符号
		4. ？：条件运算符号
		5. .（成员访问符）

19.运算符重载的三种方式？
	答：普通函数，友元函数，类成员函数。

20.流运算符为什么不能通过类的成员函数重载？一般怎么解决？
	答：因为通过类的成员函数重载必须是运算符的第一个是自己，而对流运算的重载要求第一个参数是流对象。所以一般通过友元来解决

21.赋值运算符和拷贝构造函数的区别与联系？
	答：相同点：都是将一个对象copy到另一个中去
		不同点：拷贝构造函数涉及到要新建立一个对象

22.在哪种情况下要调用该类的析构函数？
	答：对象生命周期结束时

23.对象间是怎样实现数据的共享的？
	答：通过类的静态成员变量来实现对象间的数据共享。静态成员变量占有自己独立的空间不为某个对象所私有
	
24.友元关系有什么特性？
	答：单向的，非传递的，不能继承的

25.对对象成员进行初始化的次序是什么？
	答：它的次序完全不受它们在初始化表中次序的影响，只有成员对象在类中声明的次序来决定的

26.类和对象之间的关系是什么？
	答：类是对象的抽象，对象是类的实例

27.对类的成员的访问属性有什么？
	答：public，protected，private

28．const char *p和char * const p;的区别
	答：如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
		如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量

29.是不是一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual ,也能实现多态?
	答：virtual修饰符会被隐形继承的。
		virtual可加可不加,子类覆盖它的函数不加virtual ,也能实现多态

30.函数重载是什么意思？它与虚函数的概念有什么区别？
	答：函数重载是一个同名函数完成不同的功能，编译系统在编译阶段通过函数参数个数、参数类型不同，
	函数的返回值来区分该调用哪一个函数，即实现的是静态的多态性。
	但是记住：不能仅仅通过函数返回值不同来实现函数重载。
	而虚函数实现的是在基类中通过使用关键字virtual来申明一个函数为虚函数，
	含义就是该函数的功能可能在将来的派生类中定义或者在基类的基础之上进行扩展，
	系统只能在运行阶段才能动态决定该调用哪一个函数，所以实现的是动态的多态性。
	它体现的是一个纵向的概念，也即在基类和派生类间实现

31.构造函数和析构函数是否可以被重载,为什么?
	答：构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数

32.如何定义和实现一个类的成员函数为回调函数？
	答：所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在，以后，当某个事件发生时，
		再调用这个函数对事件进行响应。
		定义一个类的成员函数时在该函数前加CALLBACK即将其定义为回调函数，函数的实现和普通成员函数没有区别

33.虚函数是怎么实现的？
	答：简单说来使用了虚函数表

34.抽象类不会产生实例，所以不需要有构造函数。 错

35.从一个模板类可以派生新的模板类，也可以派生非模板类。 对

36. main函数执行以前，还会执行什么代码？
	答案：全局对象的构造函数会在main 函数之前执行

37.当一个类A中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）
	答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了

38. delete与 delete []区别：
	答：delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数

39．子类析构时要调用父类的析构函数吗？
	答：会调用。析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了

40.继承的优缺点
	1、类继承是在编译时刻静态定义的，且可直接使用，
	2、类继承可以较方便地改变父类的实现。
	缺点：
	1、因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现
	2、父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为
	3、如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。

41.解释堆和栈的区别。 
	答：栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
	堆（heap）一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收

42.一个类的构造函数和析构函数什么时候被调用,是否需要手工调用?
	答：构造函数在创建类对象的时候被自动调用，析构函数在类对象生命期结束时，由系统自动调用

43.何时需要预编译：
	答：总是使用不经常改动的大型代码体。
		程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头

44.多态的作用？
	答：主要是两个：
		1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；
		2. 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用

45.虚拟函数与普通成员函数的区别？内联函数和构造函数能否为虚拟函数？
	答案：区别：虚拟函数有virtual关键字，有虚拟指针和虚函数表，虚拟指针就是虚拟函数的接口，而普通成员函数没有。内联函数和构造函数不能为虚拟函数

46.构造函数和析构函数的调用顺序?析构函数为什么要虚拟?
	答案：构造函数的调用顺序：基类构造函数—对象成员构造函数—派生类构造函数；
	析构函数的调用顺序与构造函数相反。析构函数虚拟是为了防止析构不彻底，造成内存的泄漏

47. C++中类型为private的成员变量可以由哪些函数访问?
	答：只可以由本类中的成员函数和友元函数访问

48.请说出类中private，protect，public三种访问限制类型的区别
	答：private是私有类型，只有本类中的成员函数访问;protect是保护型的，本类和继承类可以访问;public是公有类型，任何类都可以访问

49.类中成员变量怎么进行初始化？
	答：可以通过构造函数的初始化列表或构造函数的函数体实现	

50.在什么时候需要使用“常引用”？　
	答：如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用

51.引用与指针有什么区别？
	答： 1) 引用必须被初始化，指针不必。
		 2) 引用初始化以后不能被改变，指针可以改变所指的对象。
         3) 不存在指向空值的引用，但是存在指向空值的指针

52.描述实时系统的基本特性
	答 、在特定时间内完成特定的任务，实时性与可靠性

54.全局变量和局部变量在内存中是否有区别？如果有，是什么区别？
	答：全局变量储存在静态数据区，局部变量在堆栈中

55.堆栈溢出一般是由什么原因导致的？
	答：没有回收垃圾资源

56.什么函数不能声明为虚函数？
	答： 构造函数（constructor）

59.如何引用一个已经定义过的全局变量？
	答：可以用引用头文件的方式，也可以用extern关键字，
	如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，
	如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错

60.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?
	答：c用宏定义，c++用inline

61. C++是不是类型安全的？
	答：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)

63.简述数组与指针的区别？
	答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块

64. C++函数中值的传递方式
	答：有三种方式：值传递、指针传递、引用传递

65.内存的分配方式
	答：分配方式有三种，
		1、 静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量
		2、 栈上分配，函数内的局部变量就是从这分配的，但分配的内存容易有限
		3、 堆上分配，也称动态分配，如我们用new,malloc分配内存，用delete,free来释放的内存

66. extern“C”有什么作用？
	答：Extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数。
		这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直接调用C函数，加上extren “c”后，C++就能直接调用C函数了
		Extern “C”主要使用正规DLL函数的引用和导出 和 在C++包含C函数或C头文件时使用。使用时在前面加上extern “c” 关键字即可。
		可以用一句话概括extern “C”这个声明的真实目的：实现C++与C及其它语言的混合编程

70. #include <filename.h>和 #include “filename.h”有什么区别？
	答：对于#include <filename.h> ，编译器从标准库路径开始搜索 filename.h
		对于#include “filename.h” ，编译器从用户的工作路径开始搜索 filename.h

76. .在Win32下 char, int, float, double各占多少位？
	(1) Char 占用8位
	(2) Int 占用32位
	(3) Float 占用32位
	(4) Double 占用64位

77. strcpy()和memcpy()的区别？
	答：strcpy()和memcpy()都可以用来拷贝字符串，strcpy()拷贝以’\0’结束，但memcpy()必须指定拷贝的长度

78.说明define和const在语法和含义上有什么不同？
	答：(1) #define是C语法中定义符号变量的方法，符号常量只是用来表达一个值，在编译阶段符号就被值替换了，它没有类型；
		(2) Const是C++语法中定义常变量的方法，常变量具有变量特性，它具有类型，内存中存在以它命名的存储单元，可以用sizeof测出长度
		
81.总结static的应用和作用？
	答：（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
		（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
		（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
		（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
		（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

82.总结const的应用和作用？
	答：（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
		（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
		（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
		（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
		（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值

87.简述Debug版本和Release版本的区别？
	答：Debug版本是调试版本，Release版本是发布给用户的最终非调试的版本

89. static函数与普通函数有什么区别?
	答：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

93. assert()的作用？
	答：ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。
	如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误

95.程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中

112.什么叫静态关联，什么叫动态关联?
	答：在多态中，如果程序在编译阶段就能确定实际执行动作，则称静态关联，等到程序运行才能确定叫动态关联

114.什么叫智能指针？
	答：当一个类中，存在一个指向另一个类对象的指针时，对指针运算符进行重载，那么当前类对象可以通过指针像调用自身成员一样调用另一个类的成员

115.什么时候需要用虚析构函数？
	答：当基类指针指向用new运算符生成的派生类对象时，delete基类指针时，派生类部分没有释放掉而造成释放不彻底现象，需要虚析构函数。 补充：虚函数就是让派生类调用基类的虚函数

117.什么是平衡二叉树？
	答：左右子树都是平衡二叉树，而且左右子树的深度差值的约对值不大于1

122. memset ,memcpy的区别
	答：memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为’\0′
		memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度

124. 怎样定义一个纯虚函数？含有纯虚函数的类称为什么？
	答：在虚函数的后面加=0，含有虚函数的类称为抽象类
		在什么情况下使用纯虚函数(pure vitrual function)?
		1，当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；
		2，这个方法必须在派生类(derived class)中被实现；

125．已知strcpy函数的原型是：
	char * strcpy(char * strDest,const char * strSrc);不调用库函数，实现strcpy函数。其中，strSrc是原字符串，strDest是目标字符串 。
	答案：
		char *strcpy(char *strDest, const char *strSrc){
		if ( strDest == NULL || strSrc == NULL)
			return NULL;
		if ( strDest == strSrc)
			return strDest;
		char *tempptr = strDest; //指针tempptr指向strDest的地址；
		while( (*strDest++ = *strSrc++) != ‘\\0’){} //注意：别忘了转义符；
		return tempptr ; //返回指针向的地址；
		}


126．已知类String的原型为：
class String{
public:
String(const char *str = NULL); //普通构造函数
String(const String &other); //拷贝构造函数
~ String(void); //析构函数
String & operate =(const String &other); //赋值函数

private:
char *m_data; //用于保存字符串
};

请编写String的上述4个函数。答案：
// 普通构造函数
String::String(const char *str){
if ( str == NULL ){ //strlen在参数为NULL时会抛异常才会有这步判断
m_data = new char[1];
m_data[0] = ” ;
}else{
m_data = new char[strlen(str) + 1];
strcpy(m_data,str);
}
}
//拷贝构造函数
String::String(const String &other){
m_data = new char[strlen(other.m_data) + 1];
strcpy(m_data,other.m_data);
}
//赋值函数(重载运算符)
String & String::operator =(const String &other){
if ( this == &other)
return *this ;
delete []m_data;
m_data = new char[strlen(other.m_data) + 1];
strcpy(m_data,other.m_data);
return *this ;
}

//析构函数
String::~ String(void){
delete []m_data ;
}

135.面向对象的三个基本特征，并简单叙述之？
	1. 封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected,public)
	2. 继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。
	3. 多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针

1.名字相同的指向不同类型的指针有什么区别?
	答：计算机的CPU决了内存寻址方式，所以，不管指针所指对象是什么类型的，指针本身的规格都一样。
	如果一个指针变量的关联类型为int，则通过指针变量访问对象时，读取从指针指示的位置开始的连续4个字节，并按整型数据解释。
	如果一个指针变量的关联类型为char,则通过指针变量访问对象时，读取指针位置的当前字节，并按字符型数据解释

2.char * a[]="nieyani"这种写法对不对?
	答：这是指针数组。表示数组元素的类型是指针类型
	指针数组说明方式为：类型 * 标识符[表达式]
	例如：int * pi[3] //数组元素是关联类型为整形的指针
	            char * ps[10] //数组元素是关联类型为字符型的指针

4.如何申请一段长度为10字节的空间
	C++中malloc()函数返回的是指针
	答：int * p=（int *）malloc (10);

6.static的基本用法
	当类成员冠以static声明时，称为静态成员。“静态”是指它的作用域局部于类，一个类可以创建多个对象，因此，静态成员提供了一种同类 对象共享的机制；“成员”是指它与普通类成员一样受不同访问特性的约束。
	1.静态数据成员：在类中声明，在类外定义。尽管static数据成员从存储性质上式全局变量，但是其作用域是类。static数据成员在类外可以用“类名：：”做限定词，或通过对象访问。
	2.静态成员函数：静态成员函数提供了一个不依赖于类数据结构的共同操作，它没有this指针。因为静态成员函数只能访问类的静态数据成员

7.const基本用法
	答：用于约束对象的访问性质，使对象一旦初始化就不允许修改。它的作用分为以下几个方面：
	1）标识常量：C++语言中，当用const约束基本类型存储单元为只读事，在程序中使用存储单元的名字就像使用常数值一样，即用表示度表示常量。
	       const 类型 常量标识符=常量表达式
	2）用const约束指针对所指对象访问时，这个指针称为指向常量的指针。
	   const 类型 *指针 or 类型 const * 指针
	3）指针常量：指针变量的值只能在定义的时候初始化，定义后不能修改，即不能改变指针变量的指向。但不影响所指对象的访问特性。 类型 * const 指针 
	    const 写在指针变量名之前，表示约束指针变量本身。
	4）指向常量的指针常量：指针本身和所指对象的值在定义后都限制为只读，不能写。
	const 类型 * const 指针 or  类型 const * const 指针
	5）常引用：冠以const定义的引用，将约束对象用别名方式访问时为只读。 const 类型 & 引用名=对象名
	在类中const的用法：
	1）常数据成员
	2）常对象：若在定义对象的说明语句以const作为前缀，则该对象称为常对象。这个对象的全部数据成员在作用域中约束为只读。
	3）常成员函数：常成员函数的this指针被约束为指向常量的指针。由于this指针隐含定义，所以常成员函数在函数头以关键字const做后缀。const成员函数的函数体代码不能修改this所指对象的成员。即以const做后缀的成员函数不能修改类的数据成员也不能调用能够修改数据成员的成员函数。只能调用const成员函数。
	4）补充知识：在const成员函数中，用mutable修饰成员变量名后，就可以修改类的成员变量了

一、C和C++的区别是什么？
	C是面向过程的语言，C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。
	C中函数不能进行重载，C++函数可以重载
	C++在C的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。
	C++中struct和class除了默认访问权限外，别的功能几乎都相同

二、关键字static、const、extern作用
static和const的作用在描述时主要从类内和类外两个方面去讲：
static关键字的作用：
（1）函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
（2）在模块内的static全局变量和函数可以被模块内的函数访问，但不能被模块外其它函数访问；
（3）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
（4）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。
const关键字的作用：
（1）阻止一个变量被改变
（2）声明常量指针和指针常量
（3）const修饰形参，表明它是一个输入参数，在函数内部不能改变其值
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量(const成员一般在成员初始化列表处初始化)
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”。
extern关键字的作用：
（1）extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。
（2）extern "C"的作用是让 C++ 编译器将extern "C"声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接






//在这个类中包括了指针类成员变量m_data，当类中包括指针类成员变量时，
//一定要重载其拷贝构造函数、赋值函数和析构函数，这既是对C++程序员的基本要求

//在C++中，下面三种对象需要调用拷贝构造函数 
//1. 对象以值传递的方式传入函数参数
//2. 对象以值传递的方式从函数返回
//3. 对象需要通过另外一个对象进行初始化






1. c++常见容器，vector容器capacity和size区别，如何动态增长 
为了保证动态添加元素的高效率，因此必须预先为vector和string分配一段空间，这个空间就是capacity。
而容器中元素的个数就是size()，在容器中，capacity总是大于等于 size
当出现size > capacity的时候，如果没有空间继续容纳新的元素，不可能将它放到其他位置——因此要保证存储空间要连续。
因此，容器必须分配新的内存空间（通常比上一次的capacity大一倍），将已有的元素和新的元素拷贝到新的空间中，然后释放旧的存储空间。


2. map容器增删改查，和unorder_map区别，map底层如何实现 
	put(Object key,Object value)  添加一对键值
    get(Object key)  根据键返回相关的值，如果不存在指定的键，则返回空值。
	remove(Object key)   删除由指定的键映射的键值对
	containsKey(Object key)   如果存在由指定的键映射的键值对，返回true。
	
	c++中map与unordered_map的区别:
	头文件
	map: #include < map >
	unordered_map: #include < unordered_map >
	内部实现机理
	map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素.
	因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。

	unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的
	优缺点以及适用处
	map 
	优点： 
	有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作,红黑树，内部实现一个红黑书使得map的很多操作在lgnlgn的时间复杂度下就可以实现，因此效率非常的高
	缺点： 
	空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间
	适用处，对于那些有顺序要求的问题，用map会更高效一些
	unordered_map 
	优点： 
	因为内部实现了哈希表，因此其查找速度非常的快
	缺点： 
	哈希表的建立比较耗费时间
	适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map


3. c++智能指针 
	auto_ptr, shared_ptr, weak_ptr, unique_ptr



4. c++如何实现多态，有几种方式，动态多态和静态多态区别 
	由于有了虚函数，因此动态多态是在运行时完成的，也可以叫做运行期多态,动态多态中的接口是显式接口（虚函数）
	动态多态中的接口是显式接口（虚函数）


5. c++深拷贝浅拷贝 
	C++中类的拷贝有两种：深拷贝，浅拷贝：当出现类的等号赋值时，即会调用拷贝函数
	两个的区别
	1.在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。
		当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，
		当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。
	2.深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。
		如果对象中没有其他的资源（如：堆，文件，系统资源等），则深拷贝和浅拷贝没有什么区别
		深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值

　　深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。



6. emplace_back和push_back区别 
	emplace_back和push_back都是向容器内添加数据.
	对于在容器中添加类的对象时, 相比于push_back,emplace_back可以避免额外类的复制和移动操作.


7. 内联函数和宏的区别 
	内联函数在编译时展开，而宏在预编译时展开
	编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
	内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。
	宏不是函数，而inline是函数
	宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。



8. 编写类 String 的构造函数、析构函数和赋值函数已知类 String 的原型为： 

#include <iostream>
class String
{
public:
	String(const char *str = NULL);//普通构造函数
	String(const String &str);//拷贝构造函数
	String & operator =(const String &str);//赋值函数
	~String();//析构函数
private:
	char* m_data;//用于保存字符串
};

//普通构造函数
String::String(const char *str) {
	if (str == NULL) {
		m_data = new char[1]; //对空字符串自动申请存放结束标志'\0'的空间 
		if (m_data == NULL) {//内存是否申请成功
			std::cout << "申请内存失败！" << std::endl;
			exit(1);
		}
		m_data[0] = '\0';
	}
	else {
		int length = strlen(str);
		m_data = new char[length + 1];
		if (m_data == NULL) {//内存是否申请成功
			std::cout << "申请内存失败！" << std::endl;
			exit(1);
		}
		strcpy(m_data, str);
	}
}
//拷贝构造函数
String::String(const String &str) { //输入参数为const型
	int length = strlen(str.m_data);
	m_data = new char[length + 1];
	if (m_data == NULL) {//内存是否申请成功
		std::cout << "申请内存失败！" << std::endl;
		exit(1);
	}
	strcpy(m_data, str.m_data);
}
//赋值函数
String& String::operator =(const String &str) {//输入参数为const型
	if (this == &str) //检查自赋值
		return *this;
	int length = strlen(str.m_data);
	delete[] m_data;//释放原来的内存资源
	m_data = new char[length + 1];
	if (m_data == NULL) {//内存是否申请成功
		std::cout << "申请内存失败！" << std::endl;
		exit(1);
	}
	strcpy(m_data, str.m_data);
	return *this;//返回本对象的引用
}
//析构函数
String::~String() {
	delete[] m_data;
}

void main() {
	String a;
	String b("abc");
	system("pause");
}


9. 快速排序	
void quickSort(int arr[], int left, int right)
{
	if (left < right)
	{
		int key = arr[left];  //比较点，这是第一个坑，将left位置的value存入key中，坑就出来了
		int i = left, j = right;
		while (i < j)
		{
			while (arr[j] > key && j > i)	//arr[j] > key可以换为arr[j] >= key，但j > i不可以换为j >= i，边界问题
				j--;
			if (i < j)	
				arr[i++] = arr[j];
			while (arr[i] < key && i < j)	//同理
				i++;
			if (i < j)
				arr[j--] = arr[i];
		}
		arr[i] = key;	  //此时不用纠结是arr[i] = key还是arr[j] = key，因为i = j
		quickSort(arr, left, i - 1);
		quickSort(arr, i + 1, right);
	}



10. 如何实现一个只在堆或者栈上初始化的类

    在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的。
    静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。
	使用这种方法，直接调用类的构造函数。

    动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；
	第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。

		1、只能在堆上生成对象：将析构函数设置为私有。
			原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

		2、只能在栈上生成对象：将new 和 delete 重载为私有。
			原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。
			将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。
	
				class A {
				public:
					A() {}
					void destory() { delete this; }
				private:
					~A() {};
				};


				class B {
				private:
					void *operator new(size_t t) {}
					void operator delete (void *ptr) {}
				public:
					B() {}
					~B() {}
				};


					A a; //error
					A* ptr = new A;

					B b;
					B *ptr_1 = new B; //error


11.  c++的单例模式 
		定义一个单例类，私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。
		//单例模式
		class Singleton {
		private:
			static Singleton* instance;
		private:
			Singleton();
			~Singleton();
			Singleton(const Singleton&);
			Singleton& operator=(const Singleton&);


		public:
			static Singleton* getInstance() {
				if (instance == NULL) {
					instance = new Singleton();
				}
				return instance;
			}

		};

		Singleton* Singleton::instance = NULL;


12. 









		
		
		
		
		
		
		
		
		
		
		
		
		
		