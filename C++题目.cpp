
1.  const
	<1>修饰变量，说明该变量不可以被改变；
	<2>修饰指针，分为指向常量的指针和指针常量；
	<3>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
	<4>修饰成员函数，说明该成员函数内不能修改成员变量。


		//类
		class A{
		private:
			const int a;        // 常对象成员，只能在初始化列表赋值
		public:
			A();
			A(int x) :a(x) {};  // 初始化列表

			int getValue();         // 普通成员函数
			int getValue() const;   // 常成员函数，不得修改类中的任何数据成员的值
		};

		void function() {
			//对象
			A b;				// 普通对象，可以调用全部成员函数
			const A a;			// 常对象，只能调用常成员函数、更新常成员变量
			const A *p = &a;	// 常指针 
			const A &q = a;		// 常引用
			//指针
			char greeting[] = "Hello";				
			char *p1 = greeting;					// 指针变量，指向字符数组变量
			const char *p2 = greeting;				// 指针变量，指向字符数组常量
			char* const p3 = greeting;				// 常指针，指向字符数组变量
			const char * const p4 = greeting;		// 常指针，指向字符数组常量
		}


	void function1(const int var);		 // 传递过来的参数在函数内不可变
	void function2(const char * var);	 // 参数指针所指内容为常量
	void function3(char * const var);	 // 参数指针为常指针
	void function4(const int &var);		 // 引用参数在函数内为常量

	const int function5();			    // 返回一个常数
	const int * function6();		    // 返回一个指向常量的指针变量，使用：const int *p = function6();
	int * const function7();		    // 返回一个指向变量的常指针，使用：int* const p = function7();


2. static
	<1>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
	<2>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
	<3>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
	<4>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。	
	
	static int n;
	static void fn();

3. 	this 指针
	this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。
	当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。
	当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
	this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，
	 这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
	this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。
	在以下场景中，经常需要显式引用 this 指针：
	为实现对象的链式引用；
	为避免对同一对象进行赋值操作；
	在实现一些数据结构时，如 list。
	
4. 	inline 内联函数
			<1>相当于把内联函数里面的内容写在调用内联函数处；
			<2>相当于不用执行进入函数的步骤，直接执行函数体；
			<3>相当于宏，却比宏多了类型检查，真正具有函数特性；
			<4>不能包含循环、递归、switch 等复杂操作；
			<5>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。	

			编译器对 inline 函数的处理步骤
			将 inline 函数体复制到 inline 函数调用点处；
			为所用 inline 函数中的局部变量分配内存空间；
			将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
			如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）

	inline int functionName(int a, int b);    //声明
	inline int functionName(int a, int b) {};  //定义

	class A {
		int doA() { return 0; } //隐式内联
	};

	class B {
		int doA();
	};
	inline int A::doA() { return 0; } //需要显式内联

5. assert()
	断言，是宏，而非函数。assert 宏的原型定义在 <assert.h>（C）、<cassert>（C++）中，
	其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前

	# define NDEBUG    // 加上这行，则 assert 不可用
	#include <cassert>
		assert(p != NULL);

6. sizeof()
		sizeof 对数组，得到整个数组所占空间大小。
		sizeof 对指针，得到指针本身所占空间大小。
	
7. pragma pack (n)
		设定结构体、联合以及类成员变量以 n 字节方式对齐	

	#pragma pack(push)   // 保存对齐状态
	#pragma pack(4)      // 设定为 4 字节对齐
		struct Test {
			char m1;
			double m4;
			int m3;
		};
	#pragma pack(pop);	// 恢复对齐状态


9. 		volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
		volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
		const 可以是 volatile （如只读的状态寄存器）
		指针可以是 volatile	
		用volatile关键字声明的变量i每一次被访问时，执行部件都会从i相应的内存单元中取出i的值
	volatile int i = 10;
	
	1) 中断服务程序中修改的供其它程序检测的变量需要加volatile； 
	2) 多任务环境下各任务间共享的标志应该加volatile； 
	3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；


10. 	extern "C"
		被 extern 限定的函数或变量是 extern 类型的
		被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和连接的
		extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

		#ifdef __cplusplus
			extern "C" {
		#endif
				void *memset(void *, int, size_t);
		#ifdef __cplusplus
			}
		#endif


11. 		C++ 中 struct 和 class
			总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。
			区别:
			最本质的一个区别就是默认的访问控制
			默认的继承访问权限。struct 是 public 的，class 是 private 的。
			struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

12. explicit 修饰的构造函数可用来防止隐式转换

		class Test1 {
		public:
			Test1(int n) {
				num = n;
			}
		private:
			int num;
		};

		class Test2 {
		public:
			explicit Test2(int n) {
				num = n;
			}
		private:
			int num;
		};

		Test1 t1 = 1;	// 隐式调用其构造函数，成功
		Test2 t2 = 1;	// 编译错误，不能隐式调用其构造函数
		Test2 t3(1);    // 显式调用成功

13. enum 枚举类型
	限定作用域的枚举类型
	enum class open_modes { input, output, append };
	不限定作用域的枚举类型
	enum color { red, yellow, green };
	enum { floatPrec = 6, doublePrec = 10 };
	
14. decltype (expression)
	decltype 关键字用于检查实体的声明类型或表达式的类型及值分类	

	template <typename It>
	auto fcn(It begin, It end) -> decltype(*begin) {
		return *begin;
	}


15. 成员初始化列表
		更高效：少了一次调用默认构造函数的过程
		有些场合必须要用初始化列表：
		常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
		引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
		没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。
	
16. 面向对象三大特征 —— 封装、继承、多态
		封装:
		把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
		关键字：public, protected, friendly, private。不写默认为 friendly。
		继承:
		基类（父类）——> 派生类（子类）
		多态:
		多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。
		C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。
		多态是以封装和继承为基础的。

		动态多态（晚绑定）
		虚函数：用 virtual 修饰成员函数，使其成为虚函数
		注意：
		普通函数（非类成员函数）不能是虚函数
		静态函数（static）不能是虚函数
		构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
		内联函数不能是表现多态性时的虚函数

		纯虚函数:
		纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。
		virtual int A() = 0;


17.		虚函数、纯虚函数
		类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。
		纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
		虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。
		虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
		带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。
		抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。
		抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。
		虚函数指针、虚函数表:
		虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
		虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。
		虚继承:
		虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

		底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）
		（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

		实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；
		通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

		虚继承、虚函数：
		相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
		不同之处：
		虚继承
		虚基类依旧存在继承类中，只占用存储空间
		虚基类表存储的是虚基类相对直接继承类的偏移
		虚函数：
		虚函数不占用存储空间
		虚函数表存储的是虚函数地址
		模板类、成员模板、虚函数：
		模板类中可以使用虚函数
		一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数
		抽象类、接口类、聚合类
		抽象类：含有纯虚函数的类
		接口类：仅含有纯虚函数的抽象类
		聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
		所有成员都是 public
		没有有定于任何构造函数
		没有类内初始化
		没有基类，也没有 virtual 函数


	class C {
	public:
		void function_1(int a);
		void function_1(int a, int b); //静态多态（早绑定） //函数重载	};


	//动态多态使用
	class Shape {
	public:
		Shape();							    // 构造函数不能是虚函数
		virtual double calcArea() {};
		virtual  ~Shape();						// 虚析构函数,虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象
	};

	class Circle :public Shape {
	public:
		virtual double calcArea();
	};


18.面向对象的程序设计思想是什么？
	答：把数据结构和对数据结构进行操作的方法封装形成一个个的对象

19.什么是类？
	把一些具有共性的对象归类后形成一个集合，也就是所谓的类
	
20.对象都具有的两方面特征是什么？分别是什么含义？
	答：对象都具有的特征是：静态特征和动态特征
		静态特征是指能描述对象的一些属性（成员变量），动态特征是指对象表现出来的行为（成员函数）
		
21.在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义？
	答：这样可以提高编译效率，因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大的提高了编译效率

22.在类的内部定义成员函数的函数体，这种函数会具备那种属性？
	答：这种函数会自动为内联函数，这种函数在函数调用的地方在编译阶段都会进行代码替换	
	
23.成员函数通过什么来区分不同对象的成员数据？为什么它能够区分？
	答：通过this指针指向对象的首地址来区分的

24. C++编译器自动为类产生的四个缺省函数是什么？
	答：默认构造函数，拷贝构造函数，析构函数，赋值函数
	
25.拷贝构造函数在哪几种情况下会被调用？
	答： 1.当类的一个对象去初始化该类的另一个对象时；
         2.如果函数的形参是类的对象，调用函数进行形参和实参结合时；
         3.如果函数的返回值是类对象，函数调用完成返回时
		 
26.构造函数与普通函数相比在形式上有什么不同？（构造函数的作用，它的声明形式来分析）
	答：构造函数是类的一种特殊成员函数，一般情况下，它是专门用来初始化对象成员变量的
		构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值。
		
27.什么时候必须重写拷贝构造函数？
	答：当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝
	
28.构造函数的调用顺序是什么？
	答：1.先调用基类构造函数
		2.按声明顺序初始化数据成员
		3.最后调用自己的构造函数。
		
29.哪几种情况必须用到初始化成员列表？
	答：类的成员是常量成员初始化；
		类的成员是对象成员初始化，而该对象没有无参构造函数。
		类的成员为引用时。		
		
30.什么是常对象？
	答：常对象是指在任何场合都不能对其成员的值进行修改的对象		
		
31.静态函数存在的意义？
	答：静态私有成员在类外不能被访问，可通过类的静态成员函数来访问；		
		当类的构造函数是私有的时，不像普通类那样实例化自己，只能通过静态成员函数来调用构造函数

32.在类外有什么办法可以访问类的非公有成员？
	答：友元，继承，公有成员函数。		
		
33.什么叫抽象类？
	答：不用来定义对象而只作为一种基本类型用作继承的类		
		
34.运算符重载的意义？
	答：为了对用户自定义数据类型的数据的操作与内定义的数据类型的数据的操作形式一致		
		
35.不允许重载的5个运算符是哪些？
	答：1. .*（成员指针访问运算符号）
		2. ：：域运算符
		3. Sizeof 长度运算符号
		4. ？：条件运算符号
		5. .（成员访问符）



36.赋值运算符和拷贝构造函数的区别与联系？
	答：相同点：都是将一个对象copy到另一个中去
		不同点：拷贝构造函数涉及到要新建立一个对象

37.在哪种情况下要调用该类的析构函数？
	答：对象生命周期结束时

38.对象间是怎样实现数据的共享的？
	答：通过类的静态成员变量来实现对象间的数据共享。静态成员变量占有自己独立的空间不为某个对象所私有
	

39.对对象成员进行初始化的次序是什么？
	答：它的次序完全不受它们在初始化表中次序的影响，只有成员对象在类中声明的次序来决定的


40.是不是一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual ,也能实现多态?
	答：virtual修饰符会被隐形继承的。
		virtual可加可不加,子类覆盖它的函数不加virtual ,也能实现多态

41.函数重载是什么意思？它与虚函数的概念有什么区别？
	答：函数重载是一个同名函数完成不同的功能，编译系统在编译阶段通过函数参数个数、参数类型不同，
	函数的返回值来区分该调用哪一个函数，即实现的是静态的多态性。
	但是记住：不能仅仅通过函数返回值不同来实现函数重载。
	而虚函数实现的是在基类中通过使用关键字virtual来申明一个函数为虚函数，
	含义就是该函数的功能可能在将来的派生类中定义或者在基类的基础之上进行扩展，
	系统只能在运行阶段才能动态决定该调用哪一个函数，所以实现的是动态的多态性。
	它体现的是一个纵向的概念，也即在基类和派生类间实现

42.构造函数和析构函数是否可以被重载,为什么?
	答：构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数


43. main函数执行以前，还会执行什么代码？
	答案：全局对象的构造函数会在main 函数之前执行

44.当一个类A中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）
	答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了

45. delete与 delete []区别：
	答：delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数

46．子类析构时要调用父类的析构函数吗？
	答：会调用。析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了

47.继承的优缺点
	1、类继承是在编译时刻静态定义的，且可直接使用，
	2、类继承可以较方便地改变父类的实现。
	缺点：
	1、因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现
	2、父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为
	3、如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。

48.解释堆和栈的区别。 
	答：栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
	    堆（heap）一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收

49.虚拟函数与普通成员函数的区别？内联函数和构造函数能否为虚拟函数？
	答案：区别：虚拟函数有virtual关键字，有虚拟指针和虚函数表，虚拟指针就是虚拟函数的接口，而普通成员函数没有。内联函数和构造函数不能为虚拟函数

50.构造函数和析构函数的调用顺序?析构函数为什么要虚拟?
	答案：构造函数的调用顺序：基类构造函数—对象成员构造函数—派生类构造函数；
	析构函数的调用顺序与构造函数相反。析构函数虚拟是为了防止析构不彻底，造成内存的泄漏

51. C++中类型为private的成员变量可以由哪些函数访问?
	答：只可以由本类中的成员函数和友元函数访问

52.请说出类中private，protect，public三种访问限制类型的区别
	答：private是私有类型，只有本类中的成员函数访问;protect是保护型的，本类和继承类可以访问;public是公有类型，任何类都可以访问

53.类中成员变量怎么进行初始化？
	答：可以通过构造函数的初始化列表或构造函数的函数体实现	

54.在什么时候需要使用“常引用”？　
	答：如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用

55.引用与指针有什么区别？
	答： 1) 引用必须被初始化，指针不必。
		 2) 引用初始化以后不能被改变，指针可以改变所指的对象。
         3) 不存在指向空值的引用，但是存在指向空值的指针

56.描述实时系统的基本特性
	答：在特定时间内完成特定的任务，实时性与可靠性

57.全局变量和局部变量在内存中是否有区别？如果有，是什么区别？
	答：全局变量储存在静态数据区，局部变量在堆栈中

58.堆栈溢出一般是由什么原因导致的？
	答：没有回收垃圾资源

59.什么函数不能声明为虚函数？
	答： 构造函数（constructor）

60.如何引用一个已经定义过的全局变量？
	答：可以用引用头文件的方式，也可以用extern关键字，
		如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，
		如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错

61.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?
	答：c用宏定义，c++用inline

62. C++是不是类型安全的？
	答：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)

63.简述数组与指针的区别？
	答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块

64. C++函数中值的传递方式
	答：有三种方式：值传递、指针传递、引用传递

65.内存的分配方式
	答：分配方式有三种，
		1、 静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量
		2、 栈上分配，函数内的局部变量就是从这分配的，但分配的内存容易有限
		3、 堆上分配，也称动态分配，如我们用new,malloc分配内存，用delete,free来释放的内存

66. extern“C”有什么作用？
	答：Extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数。
		这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直接调用C函数，加上extren “c”后，C++就能直接调用C函数了
		Extern “C”主要使用正规DLL函数的引用和导出 和 在C++包含C函数或C头文件时使用。使用时在前面加上extern “c” 关键字即可。
		可以用一句话概括extern “C”这个声明的真实目的：实现C++与C及其它语言的混合编程

67. #include <filename.h>和 #include “filename.h”有什么区别？
	答：对于#include <filename.h> ，编译器从标准库路径开始搜索 filename.h
		对于#include “filename.h” ，编译器从用户的工作路径开始搜索 filename.h

68. 	
	16位编译器
	char ：1个字节
	char*(即指针变量): 2个字节
	short int : 2个字节
	int：  2个字节
	unsigned int : 2个字节
	float:  4个字节
	double:   8个字节
	long:   4个字节
	long long:  8个字节
	unsigned long:  4个字节
	 
	 
	32位编译器
	char ：1个字节
	char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
	short int : 2个字节	 
	int：  4个字节
	unsigned int : 4个字节
	float:  4个字节
	double:   8个字节
	long:   4个字节
	long long:  8个字节
	unsigned long:  4个字节
	 
	64位编译器
	char ：1个字节
	char*(即指针变量): 8个字节
	short int : 2个字节
	int：  4个字节
	unsigned int : 4个字节
	float:  4个字节
	double:   8个字节
	long:   8个字节
	long long:  8个字节
	unsigned long:  8个字节
		
	
69. strcpy()和memcpy()的区别？
	答：strcpy()和memcpy()都可以用来拷贝字符串，strcpy()拷贝以’\0’结束，但memcpy()必须指定拷贝的长度

70.说明define和const在语法和含义上有什么不同？
	答：(1) #define是C语法中定义符号变量的方法，符号常量只是用来表达一个值，在编译阶段符号就被值替换了，它没有类型；
		(2) Const是C++语法中定义常变量的方法，常变量具有变量特性，它具有类型，内存中存在以它命名的存储单元，可以用sizeof测出长度
		
71.总结static的应用和作用？
	答：（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
		（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
		（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
		（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
		（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

72.总结const的应用和作用？
	答：（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
		（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
		（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
		（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
		（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为左值（不能赋值）


73. static函数与普通函数有什么区别?
	答：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

74.程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中

75.什么叫静态关联，什么叫动态关联?
	答：在多态中，如果程序在编译阶段就能确定实际执行动作，则称静态关联，等到程序运行才能确定叫动态关联

76.什么叫智能指针？
	答：智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期

77.什么时候需要用虚析构函数？
	答：当基类指针指向用new运算符生成的派生类对象时，delete基类指针时，派生类部分没有释放掉而造成释放不彻底现象，需要虚析构函数。 补充：虚函数就是让派生类调用基类的虚函数

78.什么是平衡二叉树？
	答：左右子树都是平衡二叉树，而且左右子树的深度差值的约对值不大于1

79. memset ,memcpy的区别
	答：memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为’\0′
		memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度

80．已知strcpy函数的原型是：
	char * strcpy(char * strDest,const char * strSrc);
	不调用库函数，实现strcpy函数。其中，strSrc是原字符串，strDest是目标字符串 。
	答案：
		char *strcpy(char *strDest, const char *strSrc){
			if ( strDest == NULL || strSrc == NULL)
				return NULL;
			if ( strDest == strSrc)
				return strDest;
			char *tempptr = strDest; //指针tempptr指向strDest的地址；
			while( (*strDest++ = *strSrc++) != ‘\\0’){} //注意：别忘了转义符；
			return tempptr ; //返回指针向的地址；
		}

81．编写类 String 的构造函数、析构函数和赋值函数已知类 String 的原型为： 

		#include <iostream>
		class String
		{
		public:
			String(const char *str = NULL);//普通构造函数
			String(const String &str);//拷贝构造函数
			String & operator =(const String &str);//赋值函数
			~String();//析构函数
		private:
			char* m_data;//用于保存字符串
		};

		//普通构造函数
		String::String(const char *str) {
			if (str == NULL) {
				m_data = new char[1]; //对空字符串自动申请存放结束标志'\0'的空间 
				if (m_data == NULL) {//内存是否申请成功
					std::cout << "申请内存失败！" << std::endl;
					exit(1);
				}
				m_data[0] = '\0';
			}
			else {
				int length = strlen(str);
				m_data = new char[length + 1];
				if (m_data == NULL) {//内存是否申请成功
					std::cout << "申请内存失败！" << std::endl;
					exit(1);
				}
				strcpy(m_data, str);
			}
		}
		//拷贝构造函数
		String::String(const String &str) { //输入参数为const型
			int length = strlen(str.m_data);
			m_data = new char[length + 1];
			if (m_data == NULL) {//内存是否申请成功
				std::cout << "申请内存失败！" << std::endl;
				exit(1);
			}
			strcpy(m_data, str.m_data);
		}
		//赋值函数
		String& String::operator =(const String &str) {//输入参数为const型
			if (this == &str) //检查自赋值
				return *this;
			int length = strlen(str.m_data);
			delete[] m_data;//释放原来的内存资源
			m_data = new char[length + 1];
			if (m_data == NULL) {//内存是否申请成功
				std::cout << "申请内存失败！" << std::endl;
				exit(1);
			}
			strcpy(m_data, str.m_data);
			return *this;//返回本对象的引用
		}
		//析构函数
		String::~String() {
			delete[] m_data;
		}

		void main() {
			String a;
			String b("abc");
			system("pause");
		}

82.名字相同的指向不同类型的指针有什么区别?
	答：计算机的CPU决了内存寻址方式，所以，不管指针所指对象是什么类型的，指针本身的规格都一样。
		如果一个指针变量的关联类型为int，则通过指针变量访问对象时，读取从指针指示的位置开始的连续4个字节，并按整型数据解释。
		如果一个指针变量的关联类型为char,则通过指针变量访问对象时，读取指针位置的当前字节，并按字符型数据解释

83.char * a[]="nieyani"这种写法对不对?
	答：这是指针数组。表示数组元素的类型是指针类型
		指针数组说明方式为：类型 * 标识符[表达式]
		例如：int * pi[3] //数组元素是关联类型为整形的指针
					char * ps[10] //数组元素是关联类型为字符型的指针


84.static的基本用法
	当类成员冠以static声明时，称为静态成员。“静态”是指它的作用域局部于类，一个类可以创建多个对象，
	因此，静态成员提供了一种同类 对象共享的机制；“成员”是指它与普通类成员一样受不同访问特性的约束。
	1.静态数据成员：在类中声明，在类外定义。尽管static数据成员从存储性质上式全局变量，但是其作用域是类。static数据成员在类外可以用“类名：：”做限定词，或通过对象访问。
	2.静态成员函数：静态成员函数提供了一个不依赖于类数据结构的共同操作，它没有this指针。因为静态成员函数只能访问类的静态数据成员

85. C和C++的区别是什么？
	C是面向过程的语言，C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。
	C中函数不能进行重载，C++函数可以重载
	C++在C的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），
		而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。
	C++中struct和class除了默认访问权限外，别的功能几乎都相同

86. 关键字static、const、extern作用
	static和const的作用在描述时主要从类内和类外两个方面去讲：
	static关键字的作用：
	（1）函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
	（2）在模块内的static全局变量和函数可以被模块内的函数访问，但不能被模块外其它函数访问；
	（3）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
	（4）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。
	const关键字的作用：
	（1）阻止一个变量被改变
	（2）声明常量指针和指针常量
	（3）const修饰形参，表明它是一个输入参数，在函数内部不能改变其值
	（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量(const成员一般在成员初始化列表处初始化)
	（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”。
	extern关键字的作用：
	（1）extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。
	（2）extern "C"的作用是让 C++ 编译器将extern "C"声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接


87. c++常见容器，vector容器capacity和size区别，如何动态增长 
	为了保证动态添加元素的高效率，因此必须预先为vector和string分配一段空间，这个空间就是capacity。
	而容器中元素的个数就是size()，在容器中，capacity总是大于等于 size
	当出现size > capacity的时候，如果没有空间继续容纳新的元素，不可能将它放到其他位置——因此要保证存储空间要连续。
	因此，容器必须分配新的内存空间（通常比上一次的capacity大一倍），将已有的元素和新的元素拷贝到新的空间中，然后释放旧的存储空间。

88. map容器增删改查，和unorder_map区别，map底层如何实现 
	put(Object key,Object value)  添加一对键值
    get(Object key)  			  根据键返回相关的值，如果不存在指定的键，则返回空值。
	remove(Object key)            删除由指定的键映射的键值对
	containsKey(Object key)       如果存在由指定的键映射的键值对，返回true。
	
	c++中map与unordered_map的区别:
	头文件
	map: #include < map >
	unordered_map: #include < unordered_map >
	内部实现机理
	map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素.
	因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。

	unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的
	优缺点以及适用处
	map 
	优点： 
	有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作,红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
	缺点： 
	空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间
	适用处，对于那些有顺序要求的问题，用map会更高效一些
	unordered_map 
	优点： 
	因为内部实现了哈希表，因此其查找速度非常的快
	缺点： 
	哈希表的建立比较耗费时间
	适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map


89. c++智能指针 
	auto_ptr, shared_ptr, weak_ptr, unique_ptr

90. emplace_back和push_back区别 
	emplace_back和push_back都是向容器内添加数据.
	对于在容器中添加类的对象时, 相比于push_back,emplace_back可以避免额外类的复制和移动操作.

	
91. 如何实现一个只在堆或者栈上初始化的类
    在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的
    静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象，使用这种方法，直接调用类的构造函数。
    动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。
		1、只能在堆上生成对象：将析构函数设置为私有。
			原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。
		2、只能在栈上生成对象：将 new 和 delete 重载为私有。
			原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。
			将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。
	
				class A {
				public:
					A() {}
					void destory() { delete this; }
				private:
					~A() {};
				};

				class B {
				private:
					void *operator new(size_t t) {}
					void operator delete (void *ptr) {}
				public:
					B() {}
					~B() {}
				};

			    A a; //error
				A* ptr = new A;

				B b;
				B *ptr_1 = new B; //error

92.  c++的单例模式 
	 定义一个单例类，私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。
		//单例模式
		class Singleton {
		private:
			static Singleton* instance;
		private:
			Singleton();
			~Singleton();
			Singleton(const Singleton&);
			Singleton& operator=(const Singleton&);

		public:
			static Singleton* getInstance() {
				if (instance == NULL) {
					instance = new Singleton();
				}
				return instance;
			}
		};

		Singleton* Singleton::instance = NULL;

93. 快速排序	
void quickSort(int arr[], int left, int right)
{
	if (left < right)
	{
		int key = arr[left];  //比较点，这是第一个坑，将left位置的value存入key中，坑就出来了
		int i = left, j = right;
		while (i < j)
		{
			while (arr[j] > key && j > i)	//arr[j] > key可以换为arr[j] >= key，但j > i不可以换为j >= i，边界问题
				j--;
			if (i < j)	
				arr[i++] = arr[j];
			while (arr[i] < key && i < j)	//同理
				i++;
			if (i < j)
				arr[j--] = arr[i];
		}
		arr[i] = key;	  //此时不用纠结是arr[i] = key还是arr[j] = key，因为i = j
		quickSort(arr, left, i - 1);
		quickSort(arr, i + 1, right);
	}


94. 引用本质上是一个隐式指针，为对象的一个别名，通过操作符 & 来实现。
	C++11又提出了左值引用与右值引用的概念，一般如没有特殊说明，提到引用都是指传统的左值引用。
	这里顺便提一下变量的两个属性：左值和右值 。左值是变量的地址，右值是变量存储的内容。
	变量本质即存储空间的名称，编译后变为对应地址。
	一个C++引用声明后必须被初始化，否则编译不过，初始化之后就相当与一个变量（地址为初始化时所引用变量的地址）。
	由于拥有共同的地址，而且也是同一个类型，所以对其操作就相当于对原对象的操作，用法和普通变量相同。
	与指针最大的区别：指针是一种数据类型，而引用不是。当其用作函数传参时，传递的就是变量的左值即地址。

	函数返回值时会产生一个临时变量作为函数返回值的副本，而返回引用时不会产生值的副本
	C++( 包括 C) 中所有的表达式和变量要么是左值，要么是右值。通俗的左值的定义就是非临时对象，那些可以在多条语句中使用的对象。
	所有的变量都满足这个定义，在多条代码中都可以使用，都是左值。右值是指临时的对象，它们只在当前的语句中有效

	右值引用 (Rvalue Referene) 是 C++ 新标准 (C++11, 11 代表 2011 年 ) 中引入的新特性 , 它实现了转移语义 (Move Sementics) 和精确传递 (Perfect Forwarding)。
	详细：C++11 标准新特性: 右值引用与转移语义，它的主要目的有两个方面：
	消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；
	能够更简洁明确地定义泛型函数；
	
	右值引用形式：类型 && a= 被引用的对象。与左值的区别在于：右值是临时变量，如函数返回值，且不变。右值引用可以理解为右值的引用，右值初始化后临时变量消失。
	右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。
	临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。
	转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。
	通过转移语义，临时对象中的资源能够转移其它的对象里。

95. static
(1) 在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量
		• 静态全局变量不能被其它文件所用； 
		• 其它文件中可以定义相同名字的变量，不会发生冲突；
(2)在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量


		通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
		静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。 
		静态局部变量有以下特点：
		• 该变量在全局数据区分配内存； 
		• 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； 
		• 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0； 
		• 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；


(3)在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用
			定义静态函数的好处： 
		• 静态函数不能被其它文件所用； 
		• 其它文件中可以定义相同名字的函数，不会发生冲突；
（4）在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。
			可以看出，静态数据成员有以下特点： 
			• 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新； 
			• 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example 5中，语句int Myclass::Sum=0;是定义静态数据成员； 
			• 静态数据成员和普通数据成员一样遵从public,protected,private访问规则； 
			• 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它； 
			• 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
			＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞ 
			• 类的静态数据成员有两种访问形式：
			＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞
			如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ； 
			• 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了； 
			• 同全局变量相比，使用静态数据成员有两个优势： 
			1. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性； 
			2. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

（5）静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数
					关于静态成员函数，可以总结为以下几点： 
			• 出现在类体外的函数定义不能指定关键字static； 
			• 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 
			• 非静态成员函数可以任意地访问静态成员函数和静态数据成员； 
			• 静态成员函数不能访问非静态成员函数和非静态数据成员； 
			• 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长； 
			• 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：
			＜类名＞::＜静态成员函数名＞（＜参数表＞）
			调用类的静态成员函数。



96. new operator：指我们在C++里通常用到的关键字，比如A* a = new A;
	operator new：它是一个操作符，并且可被重载(类似加减乘除的操作符重载)
					
	A* a = new A；
	我们知道这里分为三步：1.分配内存，2.调用A()构造对象，3. 返回分配指针。
	事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，否则调用全局::operator new(size_t )，后者由C++默认提供。
	因此前面的步骤也就是：
			调用operator new (sizeof(A))
			调用A:A()
			返回指针

	内存池优化
	operator new的另一个大用处就是内存池优化，内存池的一个常见策略就是分配一次性分配一块大的内存作为内存池(buffer或pool)，然后重复利用该内存块，
	每次分配都从内存池中取出，释放则将内存块放回内存池。在我们客户端调用的是new关键字，我们可以改写operator new函数，让它从内存池中取出(当内存池不够时，
	再从系统堆中一次性分配一块大的)，至于构造和析构则在取出的内存上进行，然后再重载operator delete，它将内存块放回内存池。



1. 静态函数
	在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
	函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；
	warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

2.说一下C++中static关键字的作用
	对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。
	对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。
	对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用
	对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。

3.说一说c++中四种cast转换
		C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast
		1、const_cast
		用于将const变量转为非const
		2、static_cast
		用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
		3、dynamic_cast
		用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
		向上转换：指的是子类向基类的转换
		向下转换：指的是基类向子类的转换
		它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
		4、reinterpret_cast
		几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；
		
4.智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。
	当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。
	C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。
	只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。
	可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。


5. 请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数
	将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。
	C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。
	而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

	
5. 函数指针是指向函数的指针变量。
	函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数
	用途：调用函数和做函数的参数，比如回调函数

6.请你说说C语言参数压栈顺序？
	参考回答：从右到左

7.请你说说C++如何处理返回值？
	参考回答：生成一个临时变量，把它的引用作为函数参数传入函数内

8.请你回答一下静态函数和虚函数的区别
参考回答：静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销


9. 请你来说一下map和set有什么区别，分别又是怎么实现的？
map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。
map和set区别在于：

（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。
（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，
     如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。
		set适用场景：有序不重复集合
（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，
    因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。
	map适用场景：有序键值对不重复映射


10. 请你来说一说STL迭代器删除元素
    这个主要考察的是迭代器失效的问题。
	1.对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；
	2.对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
	3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。


11. 请你说一说STL中MAP数据存放形式
    map是红黑树。unordered map底层结构是哈希表

12. 
vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。
list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list


13. 请你来说一下STL中迭代器的作用，有指针为何还要迭代器
	迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、--等。
	迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），
	提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

	迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。
	Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果


14. 请你说一说epoll原理
首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，
接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。


15.请你回答一下什么是右值引用，跟左值又有什么区别？
	参考回答：
	右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：
	1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
	2. 能够更简洁明确地定义泛型函数。

	左值和右值的概念：
	左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象
	右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。

	右值引用和左值引用的区别：
	1. 左值可以寻址，而右值不可以。
	2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。
	3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。


16 .select，epoll的区别，原理，性能，限制都说一说
	1）IO多路复用
	IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。
    这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。
	IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。
    当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。

				所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。

				I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。

				所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）

				在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。

				2、select

				select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。

				存在的问题：

				1. 内置数组的形式使得select的最大文件数受限与FD_SIZE；

				2. 每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；

				3. 轮寻排查当文件描述符个数很多时，效率很低；

				3、poll

				poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。

				4、epoll

				epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。

				epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式

				1. LT模式

				LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。

				2. ET模式

				ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)


				ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

				3、LT模式与ET模式的区别如下：
				LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
				ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。



17. 是大端小端以及如何判断大端小端
	大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。

18. 一下静态变量什么时候初始化
   静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。
   而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造

19.死循环+来连接时新建线程的方法效率有点低，怎么改进？
	提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。
	改进死循环：使用select epoll这样的技术


20. 请你说一说什么是线程和进程，多线程和多进程通信方式
	
			1）概念：
			进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；
			线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。
			每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。
			每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。

			2）进程间通信的方式:
			进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。
			1、管道：
		管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信
		普通管道PIPE：
		它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端
		它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
		它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。
		命名管道FIFO：
		FIFO可以在无关的进程之间交换数据
		FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

		2、消息队列
		消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。
		消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。
		具有写权限得进程可以按照一定得规则向消息队列中添加新信息，对消息队列有读权限得进程则可以从消息队列中读取信息。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
		消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
		消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

		3、信号量semaphore
		信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
		信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
		信号量基于操作系统的PV 操作，程序对信号量的操作都是原子操作。
		每次对信号量的PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。支持信号量组。

		4 信号signal
		信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

		5共享内存（Shared Memory）
		它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
		共享内存是最快的一种IPC，因为进程是直接对内存进行存取,因为多个进程可以同时操作，所以需要进行同步
		信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

		6、套接字SOCKET：
		socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

		3）线程间通信的方式:
		1、临界区：
		通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
		2、互斥量 Synchronized/Lock：
		采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
		3、信号量 Semphare：
		为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
		4、事件(信号)，Wait/Notify：
		通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。


21. 进程和线程的区别，你都使用什么线程模型
			1）进程和线程区别
			1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。
			2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。
			  （资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。
			   但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
			3、进程是资源分配的最小单位，线程是CPU调度的最小单位。
			4、系统开销:由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／O设备等。
			   因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。
			5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。
			   进程间通信IPC，
			   线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。
			6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。
			7、进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。
			8、进程适应于多核、多机分布；线程适用于多核。

			2)常用线程模型

			1、Future模型

			该模型通常在使用的时候需要结合Callable接口配合使用。

			Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。

			Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。

			2、fork&join模型

			该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。

			这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。

			3、actor模型

			actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。

			4、生产者消费者模型

			生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。
			这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。
			而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。
			比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。

		

22. 系统调用是什么，你用过哪些系统调用
	1）概念：
	在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。
	操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。
	特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。
	应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，
	危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。

	2）系统调用举例：
	对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用
			
23. 请你说一下源码到可执行文件的过程
	
	1）预编译
	主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下
	1、删除所有的#define，展开所有的宏定义。

				2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。

				3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。

				4、删除所有的注释，“//”和“/**/”。

				5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。

				6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。

				2）编译

				把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。

				1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。

				2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。

				3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。

				4、优化：源代码级别的一个优化过程。

				5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。

				6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。

				3）汇编

				将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。

				4）链接

				将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：

				1、静态链接：

				函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

				空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；

				更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

				运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

				2、动态链接：

				动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

				共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；

				更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

				性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失			
							


24.请问GDB调试用过吗，什么是条件断点
	参考回答：
	1、GDB调试
	GDB 是自由软件基金会（Free Software Foundation）的软件工具之一。它的作用是协助程序员找到代码中的错误。
	如果没有GDB的帮助，程序员要想跟踪代码的执行流程，唯一的办法就是添加大量的语句来产生特定的输出。但这一手段本身就可能会引入新的错误，从而也就无法对那些导致程序崩溃的错误代码进行分析。
	GDB的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过断点暂时中止程序的执行。此外，他们还能够随时察看变量和内存的当前状态，并监视关键的数据结构是如何影响代码运行的。

	2、条件断点
	条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。
	例如：(gdb)break 666 if testsize==100							
			
			
25. 请你回答一下操作系统为什么要分内核态和用户态
为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作			


26. 请你说一下多线程的同步，锁的机制
	同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。
	对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。
	如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行


27. 你说一说线程间的同步方式，最好说出具体的系统调用
	信号量
	信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：
	P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。
	V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。
	其系统调用为：
	sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。
	sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。

	互斥量
	互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：
	pthread_mutex_init:初始化互斥锁
	pthread_mutex_destroy：销毁互斥锁
	pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。
	pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。

	条件变量
	条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。
	即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：
	pthread_cond_init:初始化条件变量
	pthread_cond_destroy：销毁条件变量
	pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。
	pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。


28. 请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题

	常见的设计模式如下：
	单例模式：
	单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
	单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。

	将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；
	在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。

	在单例模式的实现中，如果不采取任何措施，在多线程下是不安全的，可能会同时创建多个实例。因此，为了保证单例模式在多线程下的线程安全，一般采用下面几种方式实现单例模式：
	1)饿汉式：基于class loader机制避免多线程的同步问题，不过，instance在类装载时就实例化，可能会产生垃圾对象
	2)懒汉式：通过双重锁机制实现线程安全,  使用锁机制，防止多次访问,可以这样，第一次判断为空不加锁，若为空，再进行加锁判断是否为空，若为空则生成对象


	工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。

	观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新

	装饰器模式：对已经存在的某些类进行装饰，以此来扩展一些功能，从而动态的为一个对象增加新的功能。装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀
		优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
		缺点：多层装饰比较复杂。  使用场景：1、扩展一个类的功能。 2、动态增加功能，动态撤销


	
29.
	double x[5]={2.0, 4.0, 6.0, 8.0, 10.0};

		   
31.
int a[][2] = { 0 };
int b[][2] = { { 1, 2 }, { 3, 4 } };
int c[][2] = { { 1, 2,}, { 3, 4 }, {0} };
都是可以的。
但是int array[][2];不行
二维数组赋初值方法（c程序设计第三版138页）
（4）如果对全部元素都赋初值，则定义数组时第一维可以忽略，但是第二维必须存在
         同时：在定义的时候也可以对部分元素赋初值而忽略第一维的长度，但应该分行赋初值。
可见：可以忽略第一维的长度，但是是有条件的：要么你把全部元素都写出来，或者你分行写出元素（可以不全），但是不可以不赋值



32.
scanf("m=%dn=%dp=%d",&m,&n,&p);
Inputs:
m=123n=456p=789
scanf函数完全就是字符串匹配而已啦

33.
char *p[10] 是指针数组,数组里存放了10个指针,在64位系统下指针占8个字节,所以sizeof(p) = 10 * 8 = 80.
char (*p1)[10]是数组指针,p1是一个指向存放10个char类型的数组的指针,所以sizeof(p1) = 8.


34. 
do-while循环 ：在判断while条件前先执行一次do循环
static变量 ：程序再次调用时static变量的值不会重新初始化，而是在上一次退出时的基础上继续执行。


35.
非常量引用的初始值必须为左值

要理解这个先得理解左值和右值的概念
一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。
本题举例：
执行f1(0),实参0要传成A对象，那么执行
A &a1 = 0;   //这是不行的。
执行f2(0),实参0要传成A对象，那么执行 
const A &a2 = 0;//这是可行的。

左值和右值都是针对表达式而言的，左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的临时对象。
在标准C++语言中，临时量（术语为右值，因其出现在赋值表达式的右边）可以被传给函数，但只能被接受为const &类型。

函数形式参数是临时量，是右值。所以只能被接受为const &类型 。故A错。



36.
那应该是在定义数组时[ ]里只能是整型常量表达式，这里是引用数组元素，例如for循环里arr[i]经常出现，i就是整型变量


37.
p = &x;  表示的是，对x取地址，赋值给指针p，那么p 将指向 x 的那块内存空间，但是 x  是形式参数(也有人说是方法参数，都可以)，函数调用完了之后，内存就释放了，所以再返回 *p（即取出那块内存空间的值），已经找不到了。所以错误。
*p = x；  表示的是 将 x 的值赋值给 P 所指向的空间，而p之前并没有指向任何地方，这个操作将是非法的。
*p = new int(x)；   这个操作同 A 的结果一样。
p = new int(x);  new int(x) 新申请空间，调用完后不释放空间，所以将地址赋值给p 则p 指向了这段新申请内存空间，所以当做  *p 返回时，即取出p所执行空间的值，所以会输出5


38.
A： a+=(a++)    先计算a++ ，因为a为后++,a左边是左值不会报错 ;
B： a+=(++a)    先计算++a,因为a为前++, a左边是左值不会报错 ;
C:：(a++) += a  这个是错误的。因为左值只能是变量,不能是表达式，(a++)是后++, 所以a不会先计算a++,是表达式，。所以会报错。
D：(++a) +=(a++) 先计算++a,然后再去计算a +=(a++) ,所以左边也是左值 ; 




39.
cin遇到空格 结束输入，

40.
这个考点常考
“hello”存在内存常量区
char *p1 = "hello";char *p2= "hello";
那么p1==p2
但是&p1!=&p2
"hello"整个是地址，只不过cout会把它当字符串输出，这与cout输出p是一样的道理，
p也是地址，但是cout知道他是字符串的首地址，所以认为你想输出的是字符串
cout <<hex<< (int)p <<endl<< (int)("hello") << endl;
这样写，就知道p和"hello"一样，都是地址，而且它们的值相同。
另外一点，这个p指向的字符串不能修改，理由已经说了，这个字符串存在常量区
如果修改会报错。


41.
短路原则，如果是 || ，前面真后面就不执行，如果是 && 前面为真后面才执行	   
“对于逻辑表达式：a++ && b++，设a的值为0，则求解表达式的值后，b的值会发生改变”
a的值为0，又因为a++是先用a参与表达式运算，再执行a=a+1,所以表达式的值为假，后面的也不会执行	   


42.
定义一个新变量，把x赋值给它   			 int rx = x; 
定义一个int变量，把x的地址赋给它   		int rx = &x; 
定义一个int指针变量，把x的地址赋给它 	int *rx = &x; 
定义一个引用变量，即把rx定义为x的别名    int &rx = x;


43.
ios类派生istream类和ostream类，istream类和ostream类共同派生出iostream类，cin是istream类对象，cout是ostream类对象;cin和cout可以说是来自iostream类的
cin是istream的类对象
而istream的常见成员函数有：istream::getline() 函数， istream::ignore() 函数， istream::get() 函数等

44.
C语言中有数字三种表示：十进制、八进制(0开头)、十六进制(0x开头)


45.
如果大写字母变成小写字母时，就加32

46.
111111B第一位为符号位,则-2^5=-32；它的范围是从-2^5----2^5-1
如果是无符号数，，它6位数都参与预算，，111111代表的0到正63，如果是有符号数，，最高位当成符号位，不参与运算，，从0 00000到0 11111是0到31，而从1 00001 到1 11111为负1到负31，中间有一个1 00000本意表示负零，，但是负零和正零都表示零，重复了。所以计算机规定把1 00000表示-32

47.
sizeof对数组就是数组长度*数据类型长度
sizeof对指针就是int型长度
sizeof对数据类型自然是数据类型长度
sizeof对结构体需要考虑结构的字节对齐


48.
a代表数组的第一个元素  a = &a[0]  ，而&a+1就意思在整个大数组基础上，地址加“1“










		
