
1.  const
	<1>修饰变量，说明该变量不可以被改变；
	<2>修饰指针，分为指向常量的指针和指针常量；
	<3>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
	<4>修饰成员函数，说明该成员函数内不能修改成员变量。


		//类
		class A{
		private:
			const int a;        // 常对象成员，只能在初始化列表赋值
		public:
			A();
			A(int x) :a(x) {};  // 初始化列表

			int getValue();         // 普通成员函数
			int getValue() const;   // 常成员函数，不得修改类中的任何数据成员的值
		};

		void function() {
			//对象
			A b;				// 普通对象，可以调用全部成员函数
			const A a;			// 常对象，只能调用常成员函数、更新常成员变量
			const A *p = &a;	// 常指针 
			const A &q = a;		// 常引用
			//指针
			char greeting[] = "Hello";				
			char *p1 = greeting;					// 指针变量，指向字符数组变量
			const char *p2 = greeting;				// 指针变量，指向字符数组常量
			char* const p3 = greeting;				// 常指针，指向字符数组变量
			const char * const p4 = greeting;		// 常指针，指向字符数组常量
		}


	void function1(const int var);		 // 传递过来的参数在函数内不可变
	void function2(const char * var);	 // 参数指针所指内容为常量
	void function3(char * const var);	 // 参数指针为常指针
	void function4(const int &var);		 // 引用参数在函数内为常量

	const int function5();			    // 返回一个常数
	const int * function6();		    // 返回一个指向常量的指针变量，使用：const int *p = function6();
	int * const function7();		    // 返回一个指向变量的常指针，使用：int* const p = function7();


2. static
	<1>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
	<2>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
	<3>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
	<4>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。	
	
	static int n;
	static void fn();

3. 	this 指针
	this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。
	当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。
	当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
	this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，
	 这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
	this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。
	在以下场景中，经常需要显式引用 this 指针：
	为实现对象的链式引用；
	为避免对同一对象进行赋值操作；
	在实现一些数据结构时，如 list。
	
4. 	inline 内联函数
			<1>相当于把内联函数里面的内容写在调用内联函数处；
			<2>相当于不用执行进入函数的步骤，直接执行函数体；
			<3>相当于宏，却比宏多了类型检查，真正具有函数特性；
			<4>不能包含循环、递归、switch 等复杂操作；
			<5>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。	

			编译器对 inline 函数的处理步骤
			将 inline 函数体复制到 inline 函数调用点处；
			为所用 inline 函数中的局部变量分配内存空间；
			将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
			如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）

	inline int functionName(int a, int b);    //声明
	inline int functionName(int a, int b) {};  //定义

	class A {
		int doA() { return 0; } //隐式内联
	};

	class B {
		int doA();
	};
	inline int A::doA() { return 0; } //需要显式内联

5. assert()
	断言，是宏，而非函数。assert 宏的原型定义在 <assert.h>（C）、<cassert>（C++）中，
	其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前

	# define NDEBUG    // 加上这行，则 assert 不可用
	#include <cassert>
		assert(p != NULL);

6. sizeof()
		sizeof 对数组，得到整个数组所占空间大小。
		sizeof 对指针，得到指针本身所占空间大小。
	
7. pragma pack (n)
		设定结构体、联合以及类成员变量以 n 字节方式对齐	

	#pragma pack(push)   // 保存对齐状态
	#pragma pack(4)      // 设定为 4 字节对齐
		struct Test {
			char m1;
			double m4;
			int m3;
		};
	#pragma pack(pop);	// 恢复对齐状态


9. 		volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
		volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
		const 可以是 volatile （如只读的状态寄存器）
		指针可以是 volatile	
		用volatile关键字声明的变量i每一次被访问时，执行部件都会从i相应的内存单元中取出i的值
	volatile int i = 10;
	
	1) 中断服务程序中修改的供其它程序检测的变量需要加volatile； 
	2) 多任务环境下各任务间共享的标志应该加volatile； 
	3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；


10. 	extern "C"
		被 extern 限定的函数或变量是 extern 类型的
		被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和连接的
		extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

		#ifdef __cplusplus
			extern "C" {
		#endif
				void *memset(void *, int, size_t);
		#ifdef __cplusplus
			}
		#endif


11. 		C++ 中 struct 和 class
			总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。
			区别:
			最本质的一个区别就是默认的访问控制
			默认的继承访问权限。struct 是 public 的，class 是 private 的。
			struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

12. explicit 修饰的构造函数可用来防止隐式转换

		class Test1 {
		public:
			Test1(int n) {
				num = n;
			}
		private:
			int num;
		};

		class Test2 {
		public:
			explicit Test2(int n) {
				num = n;
			}
		private:
			int num;
		};

		Test1 t1 = 1;	// 隐式调用其构造函数，成功
		Test2 t2 = 1;	// 编译错误，不能隐式调用其构造函数
		Test2 t3(1);    // 显式调用成功

13. enum 枚举类型
	限定作用域的枚举类型
	enum class open_modes { input, output, append };
	不限定作用域的枚举类型
	enum color { red, yellow, green };
	enum { floatPrec = 6, doublePrec = 10 };
	
14. decltype (expression)
	decltype 关键字用于检查实体的声明类型或表达式的类型及值分类	

	template <typename It>
	auto fcn(It begin, It end) -> decltype(*begin) {
		return *begin;
	}


15. 成员初始化列表
		更高效：少了一次调用默认构造函数的过程
		有些场合必须要用初始化列表：
		常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
		引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
		没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。
	
16. 面向对象三大特征 —— 封装、继承、多态
		封装:
		把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
		关键字：public, protected, friendly, private。不写默认为 friendly。
		继承:
		基类（父类）——> 派生类（子类）
		多态:
		多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。
		C++ 多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。
		多态是以封装和继承为基础的。

		动态多态（晚绑定）
		虚函数：用 virtual 修饰成员函数，使其成为虚函数
		注意：
		普通函数（非类成员函数）不能是虚函数
		静态函数（static）不能是虚函数
		构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
		内联函数不能是表现多态性时的虚函数

		纯虚函数:
		纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。
		virtual int A() = 0;


17.		虚函数、纯虚函数
		类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。
		纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
		虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。
		虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
		带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。
		抽象类和大家口头常说的虚基类还是有区别的，在 C# 中用 abstract 定义抽象类，而在 C++ 中有抽象类的概念，但是没有这个关键字。
		抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。
		虚函数指针、虚函数表:
		虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
		虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。
		虚继承:
		虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

		底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）
		（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

		实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；
		通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

		虚继承、虚函数：
		相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
		不同之处：
		虚继承
		虚基类依旧存在继承类中，只占用存储空间
		虚基类表存储的是虚基类相对直接继承类的偏移
		虚函数：
		虚函数不占用存储空间
		虚函数表存储的是虚函数地址
		模板类、成员模板、虚函数：
		模板类中可以使用虚函数
		一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数
		抽象类、接口类、聚合类
		抽象类：含有纯虚函数的类
		接口类：仅含有纯虚函数的抽象类
		聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
		所有成员都是 public
		没有有定于任何构造函数
		没有类内初始化
		没有基类，也没有 virtual 函数


	class C {
	public:
		void function_1(int a);
		void function_1(int a, int b); //静态多态（早绑定） //函数重载	};


	//动态多态使用
	class Shape {
	public:
		Shape();							    // 构造函数不能是虚函数
		virtual double calcArea() {};
		virtual  ~Shape();						// 虚析构函数,虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象
	};

	class Circle :public Shape {
	public:
		virtual double calcArea();
	};


18.面向对象的程序设计思想是什么？
	答：把数据结构和对数据结构进行操作的方法封装形成一个个的对象

19.什么是类？
	把一些具有共性的对象归类后形成一个集合，也就是所谓的类
	
20.对象都具有的两方面特征是什么？分别是什么含义？
	答：对象都具有的特征是：静态特征和动态特征
		静态特征是指能描述对象的一些属性（成员变量），动态特征是指对象表现出来的行为（成员函数）
		
21.在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义？
	答：这样可以提高编译效率，因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大的提高了编译效率

22.在类的内部定义成员函数的函数体，这种函数会具备那种属性？
	答：这种函数会自动为内联函数，这种函数在函数调用的地方在编译阶段都会进行代码替换	
	
23.成员函数通过什么来区分不同对象的成员数据？为什么它能够区分？
	答：通过this指针指向对象的首地址来区分的

24. C++编译器自动为类产生的四个缺省函数是什么？
	答：默认构造函数，拷贝构造函数，析构函数，赋值函数
	
25.拷贝构造函数在哪几种情况下会被调用？
	答： 1.当类的一个对象去初始化该类的另一个对象时；
         2.如果函数的形参是类的对象，调用函数进行形参和实参结合时；
         3.如果函数的返回值是类对象，函数调用完成返回时
		 
26.构造函数与普通函数相比在形式上有什么不同？（构造函数的作用，它的声明形式来分析）
	答：构造函数是类的一种特殊成员函数，一般情况下，它是专门用来初始化对象成员变量的
		构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值。
		
27.什么时候必须重写拷贝构造函数？
	答：当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝
	
28.构造函数的调用顺序是什么？
	答：1.先调用基类构造函数
		2.按声明顺序初始化数据成员
		3.最后调用自己的构造函数。
		
29.哪几种情况必须用到初始化成员列表？
	答：类的成员是常量成员初始化；
		类的成员是对象成员初始化，而该对象没有无参构造函数。
		类的成员为引用时。		
		
30.什么是常对象？
	答：常对象是指在任何场合都不能对其成员的值进行修改的对象		
		
31.静态函数存在的意义？
	答：静态私有成员在类外不能被访问，可通过类的静态成员函数来访问；		
		当类的构造函数是私有的时，不像普通类那样实例化自己，只能通过静态成员函数来调用构造函数

32.在类外有什么办法可以访问类的非公有成员？
	答：友元，继承，公有成员函数。		
		
33.什么叫抽象类？
	答：不用来定义对象而只作为一种基本类型用作继承的类		
		
34.运算符重载的意义？
	答：为了对用户自定义数据类型的数据的操作与内定义的数据类型的数据的操作形式一致		
		
35.不允许重载的5个运算符是哪些？
	答：1. .*（成员指针访问运算符号）
		2. ：：域运算符
		3. Sizeof 长度运算符号
		4. ？：条件运算符号
		5. .（成员访问符）



36.赋值运算符和拷贝构造函数的区别与联系？
	答：相同点：都是将一个对象copy到另一个中去
		不同点：拷贝构造函数涉及到要新建立一个对象

37.在哪种情况下要调用该类的析构函数？
	答：对象生命周期结束时

38.对象间是怎样实现数据的共享的？
	答：通过类的静态成员变量来实现对象间的数据共享。静态成员变量占有自己独立的空间不为某个对象所私有
	

39.对对象成员进行初始化的次序是什么？
	答：它的次序完全不受它们在初始化表中次序的影响，只有成员对象在类中声明的次序来决定的


40.是不是一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual ,也能实现多态?
	答：virtual修饰符会被隐形继承的。
		virtual可加可不加,子类覆盖它的函数不加virtual ,也能实现多态

41.函数重载是什么意思？它与虚函数的概念有什么区别？
	答：函数重载是一个同名函数完成不同的功能，编译系统在编译阶段通过函数参数个数、参数类型不同，
	函数的返回值来区分该调用哪一个函数，即实现的是静态的多态性。
	但是记住：不能仅仅通过函数返回值不同来实现函数重载。
	而虚函数实现的是在基类中通过使用关键字virtual来申明一个函数为虚函数，
	含义就是该函数的功能可能在将来的派生类中定义或者在基类的基础之上进行扩展，
	系统只能在运行阶段才能动态决定该调用哪一个函数，所以实现的是动态的多态性。
	它体现的是一个纵向的概念，也即在基类和派生类间实现

42.构造函数和析构函数是否可以被重载,为什么?
	答：构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数


43. main函数执行以前，还会执行什么代码？
	答案：全局对象的构造函数会在main 函数之前执行

44.当一个类A中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）
	答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了

45. delete与 delete []区别：
	答：delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数

46．子类析构时要调用父类的析构函数吗？
	答：会调用。析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了

47.继承的优缺点
	1、类继承是在编译时刻静态定义的，且可直接使用，
	2、类继承可以较方便地改变父类的实现。
	缺点：
	1、因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现
	2、父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为
	3、如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。

48.解释堆和栈的区别。 
	答：栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
	    堆（heap）一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收

49.虚拟函数与普通成员函数的区别？内联函数和构造函数能否为虚拟函数？
	答案：区别：虚拟函数有virtual关键字，有虚拟指针和虚函数表，虚拟指针就是虚拟函数的接口，而普通成员函数没有。内联函数和构造函数不能为虚拟函数

50.构造函数和析构函数的调用顺序?析构函数为什么要虚拟?
	答案：构造函数的调用顺序：基类构造函数—对象成员构造函数—派生类构造函数；
	析构函数的调用顺序与构造函数相反。析构函数虚拟是为了防止析构不彻底，造成内存的泄漏

51. C++中类型为private的成员变量可以由哪些函数访问?
	答：只可以由本类中的成员函数和友元函数访问

52.请说出类中private，protect，public三种访问限制类型的区别
	答：private是私有类型，只有本类中的成员函数访问;protect是保护型的，本类和继承类可以访问;public是公有类型，任何类都可以访问

53.类中成员变量怎么进行初始化？
	答：可以通过构造函数的初始化列表或构造函数的函数体实现	

54.在什么时候需要使用“常引用”？　
	答：如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用

55.引用与指针有什么区别？
	答： 1) 引用必须被初始化，指针不必。
		 2) 引用初始化以后不能被改变，指针可以改变所指的对象。
         3) 不存在指向空值的引用，但是存在指向空值的指针

56.描述实时系统的基本特性
	答：在特定时间内完成特定的任务，实时性与可靠性

57.全局变量和局部变量在内存中是否有区别？如果有，是什么区别？
	答：全局变量储存在静态数据区，局部变量在堆栈中

58.堆栈溢出一般是由什么原因导致的？
	答：没有回收垃圾资源

59.什么函数不能声明为虚函数？
	答： 构造函数（constructor）

60.如何引用一个已经定义过的全局变量？
	答：可以用引用头文件的方式，也可以用extern关键字，
		如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，
		如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错

61.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?
	答：c用宏定义，c++用inline

62. C++是不是类型安全的？
	答：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)

63.简述数组与指针的区别？
	答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块

64. C++函数中值的传递方式
	答：有三种方式：值传递、指针传递、引用传递

65.内存的分配方式
	答：分配方式有三种，
		1、 静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量
		2、 栈上分配，函数内的局部变量就是从这分配的，但分配的内存容易有限
		3、 堆上分配，也称动态分配，如我们用new,malloc分配内存，用delete,free来释放的内存

66. extern“C”有什么作用？
	答：Extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数。
		这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直接调用C函数，加上extren “c”后，C++就能直接调用C函数了
		Extern “C”主要使用正规DLL函数的引用和导出 和 在C++包含C函数或C头文件时使用。使用时在前面加上extern “c” 关键字即可。
		可以用一句话概括extern “C”这个声明的真实目的：实现C++与C及其它语言的混合编程

67. #include <filename.h>和 #include “filename.h”有什么区别？
	答：对于#include <filename.h> ，编译器从标准库路径开始搜索 filename.h
		对于#include “filename.h” ，编译器从用户的工作路径开始搜索 filename.h

68. 	
	16位编译器
	char ：1个字节
	char*(即指针变量): 2个字节
	short int : 2个字节
	int：  2个字节
	unsigned int : 2个字节
	float:  4个字节
	double:   8个字节
	long:   4个字节
	long long:  8个字节
	unsigned long:  4个字节
	 
	 
	32位编译器
	char ：1个字节
	char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
	short int : 2个字节	 
	int：  4个字节
	unsigned int : 4个字节
	float:  4个字节
	double:   8个字节
	long:   4个字节
	long long:  8个字节
	unsigned long:  4个字节
	 
	64位编译器
	char ：1个字节
	char*(即指针变量): 8个字节
	short int : 2个字节
	int：  4个字节
	unsigned int : 4个字节
	float:  4个字节
	double:   8个字节
	long:   8个字节
	long long:  8个字节
	unsigned long:  8个字节
		
	
69. strcpy()和memcpy()的区别？
	答：strcpy()和memcpy()都可以用来拷贝字符串，strcpy()拷贝以’\0’结束，但memcpy()必须指定拷贝的长度

70.说明define和const在语法和含义上有什么不同？
	答：(1) #define是C语法中定义符号变量的方法，符号常量只是用来表达一个值，在编译阶段符号就被值替换了，它没有类型；
		(2) Const是C++语法中定义常变量的方法，常变量具有变量特性，它具有类型，内存中存在以它命名的存储单元，可以用sizeof测出长度
		
71.总结static的应用和作用？
	答：（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
		（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
		（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
		（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
		（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

72.总结const的应用和作用？
	答：（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
		（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
		（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
		（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
		（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为左值（不能赋值）


73. static函数与普通函数有什么区别?
	答：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

74.程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中

75.什么叫静态关联，什么叫动态关联?
	答：在多态中，如果程序在编译阶段就能确定实际执行动作，则称静态关联，等到程序运行才能确定叫动态关联

76.什么叫智能指针？
	答：智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期

77.什么时候需要用虚析构函数？
	答：当基类指针指向用new运算符生成的派生类对象时，delete基类指针时，派生类部分没有释放掉而造成释放不彻底现象，需要虚析构函数。 补充：虚函数就是让派生类调用基类的虚函数

78.什么是平衡二叉树？
	答：左右子树都是平衡二叉树，而且左右子树的深度差值的约对值不大于1

79. memset ,memcpy的区别
	答：memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为’\0′
		memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度

80．已知strcpy函数的原型是：
	char * strcpy(char * strDest,const char * strSrc);
	不调用库函数，实现strcpy函数。其中，strSrc是原字符串，strDest是目标字符串 。
	答案：
		char *strcpy(char *strDest, const char *strSrc){
			if ( strDest == NULL || strSrc == NULL)
				return NULL;
			if ( strDest == strSrc)
				return strDest;
			char *tempptr = strDest; //指针tempptr指向strDest的地址；
			while( (*strDest++ = *strSrc++) != ‘\\0’){} //注意：别忘了转义符；
			return tempptr ; //返回指针向的地址；
		}

81．编写类 String 的构造函数、析构函数和赋值函数已知类 String 的原型为： 

		#include <iostream>
		class String
		{
		public:
			String(const char *str = NULL);//普通构造函数
			String(const String &str);//拷贝构造函数
			String & operator =(const String &str);//赋值函数
			~String();//析构函数
		private:
			char* m_data;//用于保存字符串
		};

		//普通构造函数
		String::String(const char *str) {
			if (str == NULL) {
				m_data = new char[1]; //对空字符串自动申请存放结束标志'\0'的空间 
				if (m_data == NULL) {//内存是否申请成功
					std::cout << "申请内存失败！" << std::endl;
					exit(1);
				}
				m_data[0] = '\0';
			}
			else {
				int length = strlen(str);
				m_data = new char[length + 1];
				if (m_data == NULL) {//内存是否申请成功
					std::cout << "申请内存失败！" << std::endl;
					exit(1);
				}
				strcpy(m_data, str);
			}
		}
		//拷贝构造函数
		String::String(const String &str) { //输入参数为const型
			int length = strlen(str.m_data);
			m_data = new char[length + 1];
			if (m_data == NULL) {//内存是否申请成功
				std::cout << "申请内存失败！" << std::endl;
				exit(1);
			}
			strcpy(m_data, str.m_data);
		}
		//赋值函数
		String& String::operator =(const String &str) {//输入参数为const型
			if (this == &str) //检查自赋值
				return *this;
			int length = strlen(str.m_data);
			delete[] m_data;//释放原来的内存资源
			m_data = new char[length + 1];
			if (m_data == NULL) {//内存是否申请成功
				std::cout << "申请内存失败！" << std::endl;
				exit(1);
			}
			strcpy(m_data, str.m_data);
			return *this;//返回本对象的引用
		}
		//析构函数
		String::~String() {
			delete[] m_data;
		}

		void main() {
			String a;
			String b("abc");
			system("pause");
		}

82.名字相同的指向不同类型的指针有什么区别?
	答：计算机的CPU决了内存寻址方式，所以，不管指针所指对象是什么类型的，指针本身的规格都一样。
		如果一个指针变量的关联类型为int，则通过指针变量访问对象时，读取从指针指示的位置开始的连续4个字节，并按整型数据解释。
		如果一个指针变量的关联类型为char,则通过指针变量访问对象时，读取指针位置的当前字节，并按字符型数据解释

83.char * a[]="nieyani"这种写法对不对?
	答：这是指针数组。表示数组元素的类型是指针类型
		指针数组说明方式为：类型 * 标识符[表达式]
		例如：int * pi[3] //数组元素是关联类型为整形的指针
					char * ps[10] //数组元素是关联类型为字符型的指针


84.static的基本用法
	当类成员冠以static声明时，称为静态成员。“静态”是指它的作用域局部于类，一个类可以创建多个对象，
	因此，静态成员提供了一种同类 对象共享的机制；“成员”是指它与普通类成员一样受不同访问特性的约束。
	1.静态数据成员：在类中声明，在类外定义。尽管static数据成员从存储性质上式全局变量，但是其作用域是类。static数据成员在类外可以用“类名：：”做限定词，或通过对象访问。
	2.静态成员函数：静态成员函数提供了一个不依赖于类数据结构的共同操作，它没有this指针。因为静态成员函数只能访问类的静态数据成员

85. C和C++的区别是什么？
	C是面向过程的语言，C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。
	C中函数不能进行重载，C++函数可以重载
	C++在C的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），
		而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。
	C++中struct和class除了默认访问权限外，别的功能几乎都相同

86. 关键字static、const、extern作用
	static和const的作用在描述时主要从类内和类外两个方面去讲：
	static关键字的作用：
	（1）函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
	（2）在模块内的static全局变量和函数可以被模块内的函数访问，但不能被模块外其它函数访问；
	（3）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
	（4）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。
	const关键字的作用：
	（1）阻止一个变量被改变
	（2）声明常量指针和指针常量
	（3）const修饰形参，表明它是一个输入参数，在函数内部不能改变其值
	（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量(const成员一般在成员初始化列表处初始化)
	（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”。
	extern关键字的作用：
	（1）extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。
	（2）extern "C"的作用是让 C++ 编译器将extern "C"声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接


87. c++常见容器，vector容器capacity和size区别，如何动态增长 
	为了保证动态添加元素的高效率，因此必须预先为vector和string分配一段空间，这个空间就是capacity。
	而容器中元素的个数就是size()，在容器中，capacity总是大于等于 size
	当出现size > capacity的时候，如果没有空间继续容纳新的元素，不可能将它放到其他位置——因此要保证存储空间要连续。
	因此，容器必须分配新的内存空间（通常比上一次的capacity大一倍），将已有的元素和新的元素拷贝到新的空间中，然后释放旧的存储空间。

88. map容器增删改查，和unorder_map区别，map底层如何实现 
	put(Object key,Object value)  添加一对键值
    get(Object key)  			  根据键返回相关的值，如果不存在指定的键，则返回空值。
	remove(Object key)            删除由指定的键映射的键值对
	containsKey(Object key)       如果存在由指定的键映射的键值对，返回true。
	
	c++中map与unordered_map的区别:
	头文件
	map: #include < map >
	unordered_map: #include < unordered_map >
	内部实现机理
	map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素.
	因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。

	unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的
	优缺点以及适用处
	map 
	优点： 
	有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作,红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
	缺点： 
	空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间
	适用处，对于那些有顺序要求的问题，用map会更高效一些
	unordered_map 
	优点： 
	因为内部实现了哈希表，因此其查找速度非常的快
	缺点： 
	哈希表的建立比较耗费时间
	适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map


89. c++智能指针 
	auto_ptr, shared_ptr, weak_ptr, unique_ptr

90. emplace_back和push_back区别 
	emplace_back和push_back都是向容器内添加数据.
	对于在容器中添加类的对象时, 相比于push_back,emplace_back可以避免额外类的复制和移动操作.

	
91. 如何实现一个只在堆或者栈上初始化的类
    在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的
    静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象，使用这种方法，直接调用类的构造函数。
    动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。
		1、只能在堆上生成对象：将析构函数设置为私有。
			原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。
		2、只能在栈上生成对象：将 new 和 delete 重载为私有。
			原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。
			将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。
	
				class A {
				public:
					A() {}
					void destory() { delete this; }
				private:
					~A() {};
				};

				class B {
				private:
					void *operator new(size_t t) {}
					void operator delete (void *ptr) {}
				public:
					B() {}
					~B() {}
				};

			    A a; //error
				A* ptr = new A;

				B b;
				B *ptr_1 = new B; //error

92.  c++的单例模式 
	 定义一个单例类，私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。
		//单例模式
		class Singleton {
		private:
			static Singleton* instance;
		private:
			Singleton();
			~Singleton();
			Singleton(const Singleton&);
			Singleton& operator=(const Singleton&);

		public:
			static Singleton* getInstance() {
				if (instance == NULL) {
					instance = new Singleton();
				}
				return instance;
			}
		};

		Singleton* Singleton::instance = NULL;

93. 快速排序	
void quickSort(int arr[], int left, int right)
{
	if (left < right)
	{
		int key = arr[left];  //比较点，这是第一个坑，将left位置的value存入key中，坑就出来了
		int i = left, j = right;
		while (i < j)
		{
			while (arr[j] > key && j > i)	//arr[j] > key可以换为arr[j] >= key，但j > i不可以换为j >= i，边界问题
				j--;
			if (i < j)	
				arr[i++] = arr[j];
			while (arr[i] < key && i < j)	//同理
				i++;
			if (i < j)
				arr[j--] = arr[i];
		}
		arr[i] = key;	  //此时不用纠结是arr[i] = key还是arr[j] = key，因为i = j
		quickSort(arr, left, i - 1);
		quickSort(arr, i + 1, right);
	}


94. 引用本质上是一个隐式指针，为对象的一个别名，通过操作符 & 来实现。
	C++11又提出了左值引用与右值引用的概念，一般如没有特殊说明，提到引用都是指传统的左值引用。
	这里顺便提一下变量的两个属性：左值和右值 。左值是变量的地址，右值是变量存储的内容。
	变量本质即存储空间的名称，编译后变为对应地址。
	一个C++引用声明后必须被初始化，否则编译不过，初始化之后就相当与一个变量（地址为初始化时所引用变量的地址）。
	由于拥有共同的地址，而且也是同一个类型，所以对其操作就相当于对原对象的操作，用法和普通变量相同。
	与指针最大的区别：指针是一种数据类型，而引用不是。当其用作函数传参时，传递的就是变量的左值即地址。

	函数返回值时会产生一个临时变量作为函数返回值的副本，而返回引用时不会产生值的副本
	C++( 包括 C) 中所有的表达式和变量要么是左值，要么是右值。通俗的左值的定义就是非临时对象，那些可以在多条语句中使用的对象。
	所有的变量都满足这个定义，在多条代码中都可以使用，都是左值。右值是指临时的对象，它们只在当前的语句中有效

	右值引用 (Rvalue Referene) 是 C++ 新标准 (C++11, 11 代表 2011 年 ) 中引入的新特性 , 它实现了转移语义 (Move Sementics) 和精确传递 (Perfect Forwarding)。
	详细：C++11 标准新特性: 右值引用与转移语义，它的主要目的有两个方面：
	消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；
	能够更简洁明确地定义泛型函数；
	
	右值引用形式：类型 && a= 被引用的对象。与左值的区别在于：右值是临时变量，如函数返回值，且不变。右值引用可以理解为右值的引用，右值初始化后临时变量消失。
	右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。
	临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。
	转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。
	通过转移语义，临时对象中的资源能够转移其它的对象里。

95. static
(1) 在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量
		• 静态全局变量不能被其它文件所用； 
		• 其它文件中可以定义相同名字的变量，不会发生冲突；
(2)在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量


		通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
		静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。 
		静态局部变量有以下特点：
		• 该变量在全局数据区分配内存； 
		• 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； 
		• 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0； 
		• 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；


(3)在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用
			定义静态函数的好处： 
		• 静态函数不能被其它文件所用； 
		• 其它文件中可以定义相同名字的函数，不会发生冲突；
（4）在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。
			可以看出，静态数据成员有以下特点： 
			• 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新； 
			• 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example 5中，语句int Myclass::Sum=0;是定义静态数据成员； 
			• 静态数据成员和普通数据成员一样遵从public,protected,private访问规则； 
			• 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它； 
			• 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
			＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞ 
			• 类的静态数据成员有两种访问形式：
			＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞
			如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ； 
			• 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了； 
			• 同全局变量相比，使用静态数据成员有两个优势： 
			1. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性； 
			2. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

（5）静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数
					关于静态成员函数，可以总结为以下几点： 
			• 出现在类体外的函数定义不能指定关键字static； 
			• 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 
			• 非静态成员函数可以任意地访问静态成员函数和静态数据成员； 
			• 静态成员函数不能访问非静态成员函数和非静态数据成员； 
			• 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长； 
			• 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：
			＜类名＞::＜静态成员函数名＞（＜参数表＞）
			调用类的静态成员函数。



96. new operator：指我们在C++里通常用到的关键字，比如A* a = new A;
	operator new：它是一个操作符，并且可被重载(类似加减乘除的操作符重载)
					
	A* a = new A；
	我们知道这里分为三步：1.分配内存，2.调用A()构造对象，3. 返回分配指针。
	事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，否则调用全局::operator new(size_t )，后者由C++默认提供。
	因此前面的步骤也就是：
			调用operator new (sizeof(A))
			调用A:A()
			返回指针

	内存池优化
	operator new的另一个大用处就是内存池优化，内存池的一个常见策略就是分配一次性分配一块大的内存作为内存池(buffer或pool)，然后重复利用该内存块，
	每次分配都从内存池中取出，释放则将内存块放回内存池。在我们客户端调用的是new关键字，我们可以改写operator new函数，让它从内存池中取出(当内存池不够时，
	再从系统堆中一次性分配一块大的)，至于构造和析构则在取出的内存上进行，然后再重载operator delete，它将内存块放回内存池。



		
