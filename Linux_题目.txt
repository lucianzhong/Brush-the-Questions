1. 进程间主要的通讯方式？
	答：信号量，管道，消息，共享内存

2. Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别	
	IO（输入/输出）即数据的读取或者写入操作，通常用户进程的一个完整的IO操作包含：用户<-->内核，内核,<--->设备空间。IO有内存IO、网络IO和磁盘IO三种，
	5种IO模型:阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型、异步IO模型。
	
	阻塞IO模型:
    概念：进程发起IO系统调用后，进程被阻塞，转到内核处理，整个IO处理完毕后返回进程。操作成功则进程获取数据。
	
	非阻塞IO模型:
    概念：进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果缓冲区有数据，内核就会把数据返回进程
	进程轮询调用，消耗CPU的资源
	
	IO复用模型:
     概念：多个进程的IO可以注册到一个复用器（例如select）上，然后用一个进程调用该复用器，复用器会监听所有注册进来的IO；
	 如果监听的IO在内核都没有可读数据，复用器调用进程会被阻塞，当任意IO有数据，复用器调用就会返回；而后复用器调用进程可以自己通知另外的进程来发起读取IO，读取内核中准备好的数据
	 	 
	Linux中IO复用的实现方式主要有select、poll、epoll三种：
	（1）select：注册IO、阻塞扫描、监听的IO最大连接数不能多于FD_SIZE；
	（2）poll  ：原理与select相似，没有数量限制，但是IO数量大扫描线性性能下降
	（3）epoll : 事件驱动不阻塞，mmap实现内核与用户控件的消息传递，数量大。
	
	信号驱动IO模型:
      概念：当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据
	  
当前目录和上层目录： ./  ../

怎么查看当前进程？怎么执行退出？怎么查看当前路径？
	答案：查看当前进程： ps
			执行退出： exit
			查看当前路径： pwd	  
	
问题十一：
移动文件用哪个命令？改名用哪个命令？
答案： mv mv

问题十二：
复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？
答案：cp cp -r  

问题十三：
删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？
答案：rm rm -r rmdir
	
	
	
	
	
进程和线程的区别？

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2) 线程的划分尺度小于进程，使得多线程程序的并发性高。

3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别

	
	
	
线程同步的方式，互斥锁和信号量的对比 

“信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作（大家都在semtake的时候，就阻塞在 哪里）。
而互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这 个资源。
比如对全局变量的访问，有时要加锁，操作完了，在解锁。有的时候锁和信号量会同时使用的”
也就是说，信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A,B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务 并不一定是锁定某一资源，
还可以是进行一些计算或者数据处理之类。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进 行操作。在有些情况下两者可以互换。

两者之间的区别:
作用域
信号量: 进程间或线程间(linux仅线程间的无名信号量pthread semaphore)
互斥锁: 线程间
上锁时 
信号量: 只要信号量的value大于0，其他线程就可以sem_wait成功，成功后信号量的value减一。若value值不大于0，则sem_wait使得线程阻塞，直到sem_post释放后value值加一,
但是sem_wait返回之前还是会将此value值减一
互斥锁: 只要被锁住，其他任何线程都不可以访问被保护的资源	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	