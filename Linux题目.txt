 1.	进程间主要的通讯方式？
	答：信号量，管道，消息，共享内存

2.	Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别	
	IO（输入/输出）即数据的读取或者写入操作，通常用户进程的一个完整的IO操作包含：用户<-->内核，内核<--->设备空间。IO有内存IO、网络IO和磁盘IO三种，
	5种IO模型:阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型、异步IO模型。
	
	阻塞IO模型:
    概念：进程发起IO系统调用后，进程被阻塞，转到内核处理，整个IO处理完毕后返回进程。操作成功则进程获取数据	
	非阻塞IO模型:
    概念：进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果缓冲区有数据，内核就会把数据返回进程，进程轮询调用，消耗CPU的资源
	IO复用模型:
     概念：多个进程的IO可以注册到一个复用器（例如select）上，然后用一个进程调用该复用器，复用器会监听所有注册进来的IO；
	 如果监听的IO在内核都没有可读数据，复用器调用进程会被阻塞，当任意IO有数据，复用器调用就会返回；而后复用器调用进程可以自己通知另外的进程来发起读取IO，读取内核中准备好的数据	 	 
	Linux中IO复用的实现方式主要有select、poll、epoll三种：
	（1）select：注册IO、阻塞扫描、监听的IO最大连接数不能多于FD_SIZE；
	（2）poll  ：原理与select相似，没有数量限制，但是IO数量大扫描线性性能下降
	（3）epoll : 事件驱动不阻塞，mmap实现内核与用户控件的消息传递，数量大。
	
	信号驱动IO模型:
      概念：当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据
	  
3.	当前目录和上层目录： ./  ../

4.	怎么查看当前进程？怎么执行退出？怎么查看当前路径？
	答案：  查看当前进程： ps
			执行退出： exit
			查看当前路径： pwd	  
	
5.	移动文件用哪个命令？改名用哪个命令？
答案： mv mv

6.	复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？
答案：cp cp -r  
7.	删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？
答案：rm rm -r rmdir
	
8.	进程和线程的区别？
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程
2) 线程的划分尺度小于进程，使得多线程程序的并发性高
3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率
4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制
5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别

9.	线程同步的方式，互斥锁和信号量的对比 
信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作（大家都在semtake的时候，就阻塞在哪里）。

而互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这个资源。

比如对全局变量的访问，有时要加锁，操作完了，在解锁。有的时候锁和信号量会同时使用的

也就是说，信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A,B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务 并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进 行操作。在有些情况下两者可以互换。

两者之间的区别:
作用域
信号量: 进程间或线程间(linux仅线程间的无名信号量pthread semaphore)
互斥锁: 线程间
上锁时 
信号量: 只要信号量的value大于0，其他线程就可以sem_wait成功，成功后信号量的value减一。若value值不大于0，则sem_wait使得线程阻塞，直到sem_post释放后value值加一,
但是sem_wait返回之前还是会将此value值减一
互斥锁: 只要被锁住，其他任何线程都不可以访问被保护的资源	
	
10.	select,poll和epoll
   其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.
这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.

selec,poll和epoll区别总结:基本上select有3个缺点:
 1.连接数受限
 2.查找配对速度慢
 3.数据由内核拷贝到用户态
poll改善了第一个缺点
epoll改了三个缺点.


I/O多路复用技术通过把多个I/O的阻塞复用到同一个select、poll或epoll的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，
I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程。

11.	unix进程间通信方式(IPC)

	管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
	命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
	命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
	信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
	消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺
	共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
	内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
	信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
	套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

	进程间通信方式：
	管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
	信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
		因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
	消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
	共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，
		它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
	套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。


	
12. 常用的Linux命令
	（1）查看CPU利用率：top
	（2）查看当前目录：pwd和ls（ls -a可以查看隐藏目录）
	（3）切换目录：cd
	（4）查看文件占用磁盘大小：du和df
	（5）创建文件夹：mkdir
	（6）新建文件：touch
	（7）查看文件：cat
	（8）拷贝：cp  移动：mv  删除：rm
	（9）查看进程：ps，如ps aux
	（10）删除进程：kill -9 PID，注-9是参数
	（11）程序运行时间：time，使用时在命令前添加time即可，如：time ./test，可得到三个时间：real 0m0.020s，user 0m0.000s，sys 0m0.018s

		grep命令（重要的常用命令之一）：常用于打开文本修改保存，类似打windows开开TXT文本并修改；
		sed命令（常用重要命令之一）：主要用于对文件的增删改查；
		awk命令（重要常用命令之一）：取列是其擅长的；
		find 命令（常与xargs命令配合）：查找 -type 文件类型-name 按名称查找-exec执行命令；
		xargs命令：配合find/ls查找，将查找结果一条条的交给后续命令处理；

13. gdb调试工具：
	要调试C/C++的程序，一般有如下几个步骤：
	①首先在编译时，我们必须要把调试信息加到可执行文件中，编译生成可执行文件-------> g++  -g hello.cpp -o hello；
	②启动GDB编译hello程序----------> gdb hello;
	③显示源码------------> l;
	④开始调试：break 16——设置断点在16行，break func——设置断点在函数func()入口处，info break——查看断点信息，n——单步运行，c——继续运行程序，
			   r——运行程序；p i——打印i的值，finish——退出程序，q——退出gdb。


 
14. 
 lseek()函数：移动文件的读写位置
 read() write()读写文件
 pread() pwrite()带偏移量的读写文件
 都属于系统调用
 feek() 库函数

15. grep可以查找文件内容的字符
    find命令式查找对应的文件名

16.
  C 编程语言中的 malloc 、 calloc 函数和 C++ 的 new 运算符都是在动态存储区（ heap ）上申请内存空间
 
 
 
	
	
