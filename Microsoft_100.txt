This chapter discussed steering control system design for lateral lane
keeping applications.
82 Chapter 3
First, the use of full information in the form of state feedback was
presented. The lateral system is controllable and can be stabilized by state
feedback. On a straight road, with the use of a state feedback controller, all
position and yaw errors were shown to converge to zero. On a circular road,
however, these errors do not converge to zero with state feedback. The use
of a feedforward term in the control system enables the position error to
converge to zero. However, the yaw angle error will always have a steady
state value, resulting in a steady state vehicle slip angle. Equations for the
feedforward term and for the steady state slip angle were presented.
Next, control system design using output feedback was discussed. The
output measurement was assumed to be lateral position measurement with
respect to road center at a look-ahead point. Such a measurement is available
from vision cameras and can also be obtained from other types of lateral
position measurement systems. Nyquist plots were used to design a control
system. It was shown that a proportional controller could stabilize the system
if adequately large gains could be used. However, it would still suffer from
poor phase margin. The use of a lead compensator together with proportional
feedback ensures both adequate phase and gain margins and good
performance. Another important result presented in the chapter was that by
increasing the look-ahead distance at which lateral position measurement is
made, a simple lag compensator would be adequate at providing good
performance and robustness.


CHAPTER SUMMARY
The longitudinal controller in an ACC system has two modes of steady state
operation:
1) speed control
2) spacing control
Steady state spacing control is called vehicle following. In the vehicle
following mode, the longitudinal controller must ensure that the following
two properties are satisfied:
1) Individual vehicle stability, in which spacing error converges to zero
if the preceding vehicle travels at constant velocity
2) String stability, in which spacing error does not amplify as it
propagates towards the tail of a string of vehicles.
An ACC system is “autonomous” - it does not depend on wireless
communication or on cooperation from other vehicles on the highway. It
only uses on-board sensors to accomplish its control system tasks. In the
case of an autonomous controller, a constant inter-vehicle spacing policy
cannot be used. This is because an autonomous controller can ensure
individual vehicle stability but cannot ensure string stability in the case of
the constant spacing policy. Instead the constant time-gap spacing policy in
which the desired spacing is proportional to speed should be used. With the
constant time-gap spacing policy, both string stability and individual vehicle
stability can be ensured in an autonomous manner.
In addition to executing steady-state vehicle following, the longitudinal
controller must also decide which type of steady state operation is to be used
i.e. whether the vehicle should use speed control or vehicle following, based
on real-time radar measurements of range and range rate. In addition, the
controller must perform a number of transitional maneuvers, including
transitioning from spacing control to speed control when the preceding
vehicle makes a lane change, executing a “vehicle join” for closing in on a
slower moving preceding vehicle, etc. These transitional maneuvers can be
166 Chapter 6
executed based on controllers designed using R ?? R?? diagrams. R ?? R??
diagrams were discussed in section 6.7 of the chapter.




问19：解释C++中静态函数和静态变量？

答：

(1)类静态数据成员在编译时创建并初始化：在该类的任何对象建立之前就存在，不属于任何对象，而非静态类成员变量则是属于对象所有的。
类静态数据成员只有一个拷贝，为所有此类的对象所共享。

(2)类静态成员函数属于整个类，不属于某个对象，由该类所有对象共享。

1、static 成员变量实现了同类对象间信息共享。

2、static 成员类外存储，求类大小，并不包含在内。

3、static 成员是命名空间属于类的全局变量，存储在 data 区的rw段。

4、static 成员只能类外初始化。

5、可以通过类名访问（无对象生成时亦可），也可以通过对象访问。

1、静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。

2、静态成员函数只能访问静态数据成员。原因：非静态成员函数，在调用时 this指针时被当作参数传进。而静态成员函数属于类，而不属于对象，没有 this 指针。






在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate = 2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static

在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。

const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。

const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt。




















2.static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗。

 static的作用：

对变量：

1.局部变量：

在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。

  1）内存中的位置：静态存储区

  2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）

  3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。

 注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。

2.全局变量

在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。

1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）

2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）

3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。

注：static修饰全局变量，并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，
好处如下：（1）不会被其他文件所访问，修改
（2）其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用。而普通全局变量只要定义了，任何地方都能使用，使用前需要声明所有的.c文件，只能定义一次普通全局变量，但是可以声明多次（外部链接）。注意：全局变量的作用域是全局范围，但是在某个文件中使用时，必须先声明。

对类中的：

　　　　1.成员变量

　　　　用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化(初始化格式： int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化 。

　　　　特点：

不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef #define #endif或者#pragma once也不行。 
静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。
静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为 所属类类型的指针或引用。
2.成员函数

用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。
静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。base::func(5,3);当static成员函数在类外定义时不需要加static修饰符。
在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。 
不可以同时用const和static修饰成员函数。



C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。
但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。

我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，
与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。

const的作用：

 1.限定变量为不可修改。

2.限定成员函数不可以修改任何数据成员。





 
4、快速排序的思想、时间复杂度、实现以及优化方法
答：快速排序的三个步骤：
(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 "基准"（pivot）；
(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大；
(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。

基准的选择：

对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。

即：同一数组，时间复杂度最小的是每次选取的基准都可以将序列分为两个等长的；时间复杂度最大的是每次选择的基准都是当前序列的最大或最小元素；

快排代码实现：

我们一般选择序列的第一个作为基数，那么快排代码如下：

void quicksort(vector<int> &v,int left, int right)
{  
	if(left < right)//false则递归结束
	{    
		int key=v[left];//基数赋值
		int low = left;                
		int high = right;   
		while(low < high)	//当low=high时，表示一轮分割结束
		{                        
			while(low < high && v[high] >= key)//v[low]为基数，从后向前与基数比较
			{                                
				high--;                        
			}
			swap(v[low],v[high]);
 
			while(low < high && v[low] <= key)//v[high]为基数，从前向后与基数比较
			{                                
				low++;                        
			}      
			swap(v[low],v[high]);
		}                 
		//分割后，对每一分段重复上述操作
		quicksort(v,left,low-1);               
		quicksort(v,low+1,right);
	}
}
注：上述数组或序列v必须是引用类型的形参，因为后续快排结果需要直接反映在原序列中；

优化：

上述快排的基数是序列的第一个元素，这样的对于有序序列，快排时间复杂度会达到最差的o(n^2)。所以，优化方向就是合理的选择基数。

常见的做法“三数取中”法（序列太短还要结合其他排序法，如插入排序、选择排序等），如下：

①当序列区间长度小于 7 时，采用插入排序；
②当序列区间长度小于 40 时，将区间分成2段，得到左端点、右端点和中点，我们对这三个点取中数作为基数；
③当序列区间大于等于 40 时，将区间分成 8 段，得到左三点、中三点和右三点，分别再得到左三点中的中数、中三点中的中数和右三点中的中数，再将得到的三个中数取中数，然后将该值作为基数。
具体代码只是在上一份的代码中将“基数赋值”改为①②③对应的代码即可：

		int key=v[left];//基数赋值
		if(right-left+1<=7){
			insertion_sort(v,left,right);//插入排序
			return;
		}else if(right-left+1<=8){
			key=SelectPivotOfThree(v,left,right);//三个取中
		}else{
			//三组三个取中，再三个取中（使用4次SelectPivotOfThree，此处不具体展示）
		}
需要调用的函数：
void insertion_sort(vector<int> &unsorted,int left, int right)  //插入排序算法      
{        
	for (int i = left+1; i <= right; i++)        
	{        
		if (unsorted[i - 1] > unsorted[i])        
		{       
			int temp = unsorted[i];       
			int j = i;       
			while (j > left && unsorted[j - 1] > temp)
         
			{         
				unsorted[j] = unsorted[j - 1];        
				j--;      	
			}   
			unsorted[j] = temp;    
		}    
	}   
}
 
int SelectPivotOfThree(vector<int> &arr,int low,int high)  //三数取中，同时将中值移到序列第一位
{  
    int mid = low + (high - low)/2;//计算数组中间的元素的下标  
  
    //使用三数取中法选择枢轴
    if (arr[mid] > arr[high])//目标: arr[mid] <= arr[high]  
    {  
        swap(arr[mid],arr[high]);
    }  
    if (arr[low] > arr[high])//目标: arr[low] <= arr[high]  
    {  
        swap(arr[low],arr[high]);
    }  
    if (arr[mid] > arr[low]) //目标: arr[low] >= arr[mid]  
    {  
        swap(arr[mid],arr[low]);
    }  
    //此时，arr[mid] <= arr[low] <= arr[high]  
    return arr[low];  
    //low的位置上保存这三个位置中间的值  
    //分割时可以直接使用low位置的元素作为枢轴，而不用改变分割函数了  
}  

这里需要注意的有两点：

①插入排序算法实现代码；

②三数取中函数不仅仅要实现取中，还要将中值移到最低位，从而保证原分割函数依然可用。




I/O多路复用技术通过把多个I/O的阻塞复用到同一个select、poll或epoll的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，
I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程。

（2）select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的
，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

（3）I/O多路复用的主要应用场景如下：


6、常用的Linux命令
答：（1）查看CPU利用率：top

（2）查看当前目录：pwd和ls（ls -a可以查看隐藏目录）

（3）切换目录：cd

（4）查看文件占用磁盘大小：du和df

（5）创建文件夹：mkdir

（6）新建文件：touch

（7）查看文件：cat

（8）拷贝：cp  移动：mv  删除：rm

（9）查看进程：ps，如ps aux

（10）删除进程：kill -9 PID，注-9是参数

（11）程序运行时间：time，使用时在命令前添加time即可，如：time ./test，可得到三个时间：real 0m0.020s，user 0m0.000s，sys 0m0.018s

grep命令（重要的常用命令之一）：常用于打开文本修改保存，类似打windows开开TXT文本并修改；

sed命令（常用重要命令之一）：主要用于对文件的增删改查；

awk命令（重要常用命令之一）：取列是其擅长的；

find 命令（常与xargs命令配合）：查找 -type 文件类型-name 按名称查找-exec执行命令；

xargs命令：配合find/ls查找，将查找结果一条条的交给后续命令处理；

gdb调试工具：

要调试C/C++的程序，一般有如下几个步骤：

①首先在编译时，我们必须要把调试信息加到可执行文件中，编译生成可执行文件-------> g++  -g hello.cpp -o hello；

②启动GDB编译hello程序----------> gdb hello;

③显示源码------------> l;

④开始调试：break 16――设置断点在16行，break func――设置断点在函数func()入口处，info break――查看断点信息，n――单步运行，c――继续运行程序，
r――运行程序；p i――打印i的值，finish――退出程序，q――退出gdb。



15. 两条相交的单向链表，如何求他们的第一个公共节点
16、求单向局部循环链表的环入口

 
多线程的主要优点包括: 

(1)多线程技术使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态；

(2)占用大量处理时间的任务使用多线程可以提高CPU利用率，即占用大量处理时间的任务可以定期将处理器时间让给其它任务；

(3)多线程可以分别设置优先级以优化性能。

以下是最适合采用多线程处理：

(1)耗时或大量占用处理器的任务阻塞用户界面操作;

(2)各个任务必须等待外部资源 (如远程文件或 Internet连接)。

多线程的主要缺点包括：

(1)等候使用共享资源时造成程序的运行速度变慢。这些共享资源主要是独占性的资源 ,如打印机等。

(2)对线程进行管理要求额外的 CPU开销，线程的使用会给系统带来上下文切换的额外负担。

(3)线程的死锁。即对共享资源加锁实现同步的过程中可能会死锁。

(4)对公有变量的同时读或写，可能对造成脏读等；



3、Top K问题
答：Top k问题即：在大量数据（n>>100000）中查找前k个最大的数据。

思路：排序是不可取的，因为大量数据排序耗时太大，且空间复杂度也很大，一般利用数据结构的最小堆（最小堆即父节点的值小于等于孩子节点的数值）来处理；

具体做法：建立一个含有K个节点的最小堆，遍历海量数据分别与根节点比较，若小于根节点则舍弃，否则用新数值替换根节点数值，并进行最小堆的调整，那么最终得到的堆节点就是最大的k个数据。

时间复杂度=nlogK（堆调整时间复杂度为logK）；

此题若用于热门搜索推荐，即所有搜索项若都在日志文件中，查找搜索次数最多的K项。那么在top K计算之前还去要去统计每一搜索项的个数，此时需要用到数据结构――hashtable；



面试题

腾讯：

1、比如说我们要视频聊天，TCP和UDP应该选哪个（考察TCP与UDP的差别与各自的优点）

2、虚函数的数据结构，如何工作

3、const和define的区别

4、栈和循环哪个效率更高

5、设计模式的一些问题，单例模式如何实现，抽象工厂模式等

6、构造函数和析构函数是否可以为虚函数，为什么

7、两个有序数组合并成一个有序数组（写代码）

百度：

1、项目相关问题

2、TCP的三次握手过程

3、进程的上下文切换

4、字符串中查找第一次出现的字符（写代码）

5、多个有序链表合并成一个有序链表（写代码）

小米：

1、项目相关问题

2、vector中push_back一个元素是如何实现的

3、建堆（写代码）

搜狗：

1、项目相关问题

2、实现String类（写代码）

3、关于26进制的转换（写代码）

中兴：

1、项目相关问题

2、虚函数与纯虚函数的区别

3、指针与引用的区别

4、哈希表的查找

华为：

1、项目相关问题

2、一些排序算法

3、不用临时变量实现两个变量的交换

4、函数指针与指针函数

5、最短路径问题

还有面试的一些其他公司的一些题目：

1、单核多线程如何实现

2、进程和线程的区别

3、Linux线程使用的API

4、两个栈实现一个队列

5、不知栈的深度用哪个数据结构



7、进程间通信方式和线程间通信方式
答：（1）进程间通信方式：

# 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

# 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。


# 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

# 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。


# 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。



（2）线程间通信方式：

#全局变量；

#Messages消息机制；

#CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）。



11. 已知 strcpy 的函数原型：char *strcpy(char *strDest, const char *strSrc)其中 strDest 是
目的字符串，strSrc 是源字符串。不调用 C++/C 的字符串库函数，请编写函数 strcpy。
答案：
char *strcpy(char *strDest, const char *strSrc)
{
if ( strDest == NULL || strSrc == NULL)
 3
return NULL ;
if ( strDest == strSrc)
return strDest ;
char *tempptr = strDest ;
while( (*strDest++ = *strSrc++) != ‘\0’);
return tempptr ;
}
12. 已知 String 类定义如下：
class String
{
public:
String(const char *str = NULL); // 通用构造函数
String(const String &another); // 拷贝构造函数
~ String(); // 析构函数
String & operater =(const String &rhs); // 赋值函数
private:
char *m_data; // 用于保存字符串
};
尝试写出类的成员函数实现。
答案：
String::String(const char *str)
{
if ( str == NULL ) //strlen 在参数为 NULL 时会抛异常才会有这步判断
{
m_data = new char[1] ;
m_data[0] = ‘\0’ ;
}
else
{
m_data = new char[strlen(str) + 1];
strcpy(m_data,str);
}
}
String::String(const String &another)
{
m_data = new char[strlen(another.m_data) + 1];
strcpy(m_data,other.m_data);
}
String& String::operator =(const String &rhs)
{
if ( this == &rhs)
return *this ;
delete []m_data; //删除原来的数据，新开一块内存
m_data = new char[strlen(rhs.m_data) + 1];
strcpy(m_data,rhs.m_data);
return this ;
}
String::~String()
{
delete []m_data ;
}















#include <list>
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include<stack>
#include<thread>
using namespace std;


struct ListNode {
	int value;
	ListNode *next;
};


struct TreeNode {
	int value;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int n) :value(n),left(NULL),right(NULL){}
};

///////////////////////////////////////////
ListNode * ReverseList(ListNode *head) {

	return NULL;
}

////////////////////////////////////
ListNode* MergeList(ListNode* ListHeadNodeOne, ListNode* ListHeadNodeTwo) {
	if (ListHeadNodeOne == NULL) {
		return ListHeadNodeTwo;
	}
	else if (ListHeadNodeTwo == NULL) {
		return ListHeadNodeTwo;
	}

	ListNode *Merged_List = NULL;
	if (ListHeadNodeOne->value <= ListHeadNodeTwo->value) {
		Merged_List = ListHeadNodeOne;
		Merged_List->next = MergeList(ListHeadNodeOne->next, ListHeadNodeTwo);
	}
	else if (ListHeadNodeOne->value > ListHeadNodeTwo->value) {
		Merged_List = ListHeadNodeTwo;
		Merged_List->next = MergeList(ListHeadNodeOne,ListHeadNodeTwo->next);
	}
	return Merged_List;
}
//////////////////////////////////
int Height_tree(TreeNode * root) {
	if (root == NULL) {
		return 0;
	}
	else {
		int height = Height_tree(root->left) > Height_tree(root->right) ? Height_tree(root->left) + 1 : Height_tree(root->right) + 1;

		return height;
	}
}


int TreeDistance(TreeNode *root) {
	int maxDisatnce = 0;
	int distanceTree = 0;
	if (root == NULL) {
		return 0;
	}
	else if (root->left == NULL || root->right == NULL) {
		return 0;
	}			
		distanceTree = max(TreeDistance(root->left), TreeDistance(root->right));
		distanceTree = max((Height_tree(root->left) + Height_tree(root->right)), distanceTree);	
	if (maxDisatnce < distanceTree) {
		maxDisatnce = distanceTree;
	}
	return maxDisatnce;
}

///////////////////////////////////
int sum(int n) {
	int res = n;	
	res && (res+=sum(n - 1));
	return res;
}

/////////////////////
ListNode * Kth_Node(ListNode *root, int k) {
	ListNode *fast_node = root + k;
	ListNode *slow_node = root;

	while (fast_node != NULL) {
		slow_node = slow_node->next;
	}
	return slow_node;
}
//////////////////////////////
vector<int> findAns(vector<int> data, int sum) {
	vector<int> res;
	int start = 0;
	int end = data.size() - 1;

	while (start < end) {
		if ((data[start] + data[end]) > sum) {
			end--;
		}
		else if((data[start]+data[end])<sum){
			start++;
		}
		else {
			res = { start,end };
			return  res;
		}
	}
	return res;
}
//////////////////////////
TreeNode * Mirror_TreeNode(TreeNode *root) {
	if (root != NULL){
		swap(root->left, root->right);
	Mirror_TreeNode(root->left);
	Mirror_TreeNode(root->right);
	}
	return root;
}

//////////////////////////////////////
void BreadthTraverse(TreeNode *root) {
	queue<TreeNode *> node_queue;
	node_queue.push(root);
	TreeNode *node;

	while (!node_queue.empty()) {
		node = node_queue.front();
		cout << node->value << endl;
		node_queue.pop();
		if (node->left != NULL) {
			node_queue.push(node->left);
		}
		if (node->right != NULL) {
			node_queue.push(node->right);
		}
	}
}
/////////////////////////
int FirstNotRepeatingChar(string str) {
	int hash[] = {0};
	for (int i=0; i < str.length(); i++) {
		hash[str[i]]++;
	}
	for (int i=0; i < str.length(); i++) {
		if (hash[str[i]] == 1) {
			return i;
		}
		
	}
	return -1;
}

////////////////////////////

int Fibonacci(int n) {
	if (n == 1 || n == 2) {
		return n;
	}
	else {

		return (Fibonacci(n - 1) + Fibonacci(n - 2));

	}

}

////////////////////////////
/*
第21题（数组）
2010年中兴面试题
编程求解：
输入两个整数 n 和 m，从数列1，2，3.......n 中 随意取几个数,
使其和等于 m, 要求将其中所有的可能组合列出来.
类似这种组合问题一般都是使用递归的策略，考虑到n个数和为m,假设要解决的函数为f(n,m), 假设我们选择了第n个数，那么问题就变成了f(n-1,m-n)，
否则的话问题就是f(n-1,m), 再考虑下边界条件： 如果n<1 或者 m<1显然不会有结果， 如果n==m，那么显然可以输出一个结果了,然后问题就变成了f(m-1,m)
*/
void BagProblem(int n, int m){
	vector<int> res;
	if (n == 1 || m == 1) {
		return;
	}
	if (m>n) {
		res.push_back(n);
		BagProblem(n - 1, m - n);//选择n
		res.pop_back();
		BagProblem(n - 1, m);//not choose n
	}
	else {
		vector<int>::iterator it;
		for (it = res.begin(); it < res.end(); it++) {
			cout << *it << endl;
		}
		cout << m << endl; //当m<n时，一定可以输出m，然后在递归
		BagProblem(m - 1, m); 
	}
}

//24. 单链表反序（反转），使用stack
void Reverse_List(ListNode *head) {
	if (head == NULL || head->next == NULL) {
		return;
	}	
	stack<ListNode *>reverse_list;
	while (head->next != NULL) {
		reverse_list.push(head->next);
		head = head->next;
	}
	while (!reverse_list.empty()) {
		head->next = reverse_list.top();//让头节点指向（栈顶元素中所存的第一个节点的地址）
		head = reverse_list.top();//链表指针后移
		reverse_list.pop();
	}
	head->next = NULL; // 令链表末尾指向NULL
}

//25 在字符串中找出连续最长的数字串，并把这个串的长度返回，
int LongestNumberString(string str) {
	int len = str.size();
	string buffer;
	string out;
	int max = 0;
	for (int i = 0; i < len; i++) {
		if (str[i] >= '0'  && str[i] <= '9') {
			buffer += str[i];

			while (str[i + 1] >= '0' && str[i + 1] <= '9') {
				buffer += str[i + 1];
				i++;
				if (buffer.size() > max) {
					max = buffer.size();
					out = buffer;
				}
				else if (buffer.size() == max) {
					out += buffer;
				}
				buffer.clear();
			}
			return max;
		}		
	}
	return 0;
}

//26 左旋转字符串（字符串）
string LeftRotateString(string str, int n) {
	int len = str.size();
	if (len == 0) {
		return " " ;
	}
	n = n%len;
	str += str;
	return (str.substr(n,len));
}

//27
//跳台阶问题（递归）


//28

int NumberOfOne(int n) {
	int i = 0;
	if (n > 0) {
		if (n & 1 == 1) {
			i++;
		}
		n >>=1;
		}
	return i;
}

//29
//输入两个整数序列。其中一个序列表示栈的push顺序，判断另一个序列有没有可能是对应的pop顺序
bool IsPopOrder(vector<int> pushV, vector<int> popV) {
	stack<int> buffer;
	
	for (int i = 0; i < pushV.size(); i++) {
		buffer.push(pushV[i]);
	}
	int j = 0;
	while (j < buffer.size() && buffer.top() == popV[j]) {
		j++;
		buffer.pop();
	}
	return (buffer.empty());
}




//30 
//在从1到n的正数中1出现的次数（数组）
int ComputeNum1(int n) {
	int count = 0;
	for (int i = 0; i < n; i++) {
		while (i) {
			if (i % 10 == 1) {
				count++;
			}
			i /= 10;
		}
	}
	return count;
}

//31
//实现一个队列。队列的应用场景为：一个生产者线程将int类型的数入列，一个消费者线程将int类型的数出列
// mutex or PV for multi-thread







//32
//求一个矩阵中最大的二维矩阵(元素和最大)
// max sub-array of an array of number n
int Max_Array(int a[], int n) {
	int buffer = 0;
	int sum = a[0];
	for (int i = 0; i < n; i++) {
		if (buffer > 0) {
			buffer += a[0];
		}
		else {
			buffer = a[i];
		}
	
		if (buffer > sum) {
			sum = buffer;
		}
		return sum;
	}
}


int maxSubMatrix(int array[][3], int n)
{
	int i, j, k, max = 0, sum = -100000000;
	int b[] = {0};

	for (k = 0; k<n; k++)//初始化b[]
	{
		b[k] = 0;
	}

	for (i = 0; i<n; i++)
	{
		
		for (j = i; j<n; j++)//把第i行到第j行相加,对每一次相加求出最大值
		{
			for (k = 0; k<n; k++)
			{
				b[k] += array[j][k];//j行的所有列
			}
			max = Max_Array(b, n);
			if (max>sum)
			{
				sum = max;
			}
		}
	}
	return sum;
}


//33















//34









//35








//36





//37







//38









//39










//40








//41






	
int main() {
	int a[] = { 1, 2, 3, 10, 4, 7, 2, 5 };

	cout << sum(3) << endl;


	return 0;
}
	


