

# <1> Python的函数参数传递
#这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。
#在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点)
#当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.
#所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.
#而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.


a = 1
def fun(a):
    print ("func_in",id(a) )  # func_in 41322472
    a = 2
    print ("re-point",id(a), id(2) )  # re-point 41322448 41322448
print ("func_out",id(a), id(1) ) # func_out 41322472 41322472
fun(a)
print (a)  # 1


a = []
def fun(a):
    print ("func_in",id(a) ) # func_in 53629256
    a.append(1)
print  ("func_out",id(a) )    # func_out 53629256
fun(a)
print (a)  # [1]


# <2> Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和 实例方法

def foo(x):
	print("excuting foo(%s,%s)"%(self,x))

class A(object):
	def foo(self,x):
		print("excuting foo(%s,%s)"%(self,x))

	@classmethod
	def class_foo(cls,x):
		print("excuting class_foo(%s,%s)"%(cls,x))

	@staticmethod
	def static_foo(x):
		print("excuting static_foo(%s)"%x)

a=A()

#这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用foo(x),这个函数就是最常用的,
#它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是foo(self, x),为什么要这么做呢?
#因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的a.foo(x)(其实是foo(a, x)).类方法一样,
#只不过它传递的是类而不是实例,A.class_foo(x).注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.

#				实例方法		类方法					静态方法
#   a = A()		a.foo(x)	a.class_foo(x)		a.static_foo(x)
#   A	    	不可用	    A.class_foo(x)		A.static_foo(x)



#<3> 类变量和实例变量
#类变量：​	是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。
#实例变量：实例化之后，每个实例单独拥有的变量。



#<4> Python自省,这个也是python彪悍的特性.
#自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
a=[1,2,3,4]
b={'a':1,'b':2,'c':3}
c=True
print (type(a),type(b),type(c))
print(isinstance(a,list))


# <5> 推导式comprehensions（又称解析式），是Python的一种独有特性。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。共有三种推导式，在Python2和3中都有支持：
#列表(list)推导式
#字典(dict)推导式
#集合(set)推导式

#过滤掉长度小于3的字符串列表，并将剩下的转换成大写字母  #list
names = ['Bob','Tom','alice','Jerry','Wendy','Smith']
[name.upper() for name in names if len(name)>3] 
print(names)

# 快速更换key和value   #dict
mcase = {'a': 10, 'b': 34}
mcase_frequency = {v: k for k, v in mcase.items()}
print(mcase_frequency)


# 集合推导式跟列表推导式也是类似的。 唯一的区别在于它使用大括号{ }
squared = {x**2 for x in [1, 1, 4]}
print(squared)




# <6> Python中单下划线和双下划线

#__foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如__init__(),__del__(),__call__()这些特殊方法
#_foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；
#__foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.



#  <7>  迭代器和生成器
# 这里有个关于生成器的创建问题面试官有考： 问： 将列表生成式中[]改成() 之后数据结构是否改变？ 答案：是，从列表变为生成器

L=[x*x for x in range(10)]
G=(x*x for x in range(10))
print(L)
print(G)
print (next(G))
print(list(G))

print(  sum( [i for i in range(10000)])  )
print ( sum( (i for i in range(10000)) ) )

# 通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，
# 如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。
#在Python中，我们可以采用生成器：边循环，边计算的机制—>generator



#<7>  *args and **kwargs
#当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数
# **kwargs允许你使用没有事先定义的参数名

#<8> 装饰器的作用就是为已经存在的对象添加额外的功能
#装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，
#有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能


# <9>  鸭子类型
# 比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。
#又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.
#鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式



# <10> 动态语言Python
#强类型语言(静态类型语言)是指需要进行变量/对象类型声明的语言，一般情况下需要编译执行。例如C/C++/Java/C
#弱类型语言(动态类型语言)是指不需要进行变量/对象类型声明的语言，一般情况下不需要编译(但也有编译型的)。例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。

#函数重载主要是为了解决两个问题。1。可变参数类型。2。可变参数个数。
#另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，
#如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。好吧，
#那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，
#如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。
#那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？
#大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。
#好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了



# <11> GIL线程全局锁
#线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.
#对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。
#解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).
#简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.
#Python里最常见的yield就是协程的思想!可以查看第九个问题.


#  <12> Python函数式编程
a=[1,2,3,4,5]
b=filter(lambda x:x>3,a)
print(list(b))

# <13>  copy(),deepcopy()的区别
#—–我们寻常意义的复制就是深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。 
#—–而浅复制并不会产生一个独立的对象单独存在，他只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，
#另一个标签也会随之改变。这就和我们寻常意义上的复制有所不同了。



# <13> select,poll和epoll
# 其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.

# 这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.

# selec,poll和epoll区别总结:基本上select有3个缺点:

# 1.连接数受限
# 2.查找配对速度慢
# 3.数据由内核拷贝到用户态
# poll改善了第一个缺点
# epoll改了三个缺点.



#<14>  unix进程间通信方式(IPC)
"""
1. 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
2. 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
	命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
3. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
4. 消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺
5. 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
6. 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
7. 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
8. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
"""


